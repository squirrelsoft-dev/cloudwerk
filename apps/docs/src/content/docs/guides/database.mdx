---
title: Database (D1)
description: Work with Cloudflare D1 SQL database in your Cloudwerk application.
---

import { Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

Cloudwerk provides first-class integration with Cloudflare D1, a serverless SQLite database that runs at the edge.

## Getting Started

### Create a D1 Database

<Steps>
1. Create a new D1 database:

   ```bash
   wrangler d1 create my-database
   ```

2. Copy the database ID from the output and add it to `wrangler.toml`:

   ```toml
   [[d1_databases]]
   binding = "DB"
   database_name = "my-database"
   database_id = "your-database-id"
   ```

3. Configure Cloudwerk to use the database:

   ```typescript
   // cloudwerk.config.ts
   import { defineConfig } from '@cloudwerk/core';

   export default defineConfig({
     database: {
       binding: 'DB',
     },
   });
   ```
</Steps>

### Database Migrations

Create migrations in the `migrations/` directory:

```sql
-- migrations/0001_create_users.sql
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  password_hash TEXT NOT NULL,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_users_email ON users(email);
```

Run migrations:

```bash
# Local development
wrangler d1 migrations apply my-database --local

# Production
wrangler d1 migrations apply my-database --remote
```

## Query Builder

Cloudwerk includes a type-safe query builder:

### Select Queries

```typescript
// Get all users
const users = await context.db
  .selectFrom('users')
  .execute();

// Get single user by ID
const user = await context.db
  .selectFrom('users')
  .where('id', '=', userId)
  .executeTakeFirst();

// Select specific columns
const emails = await context.db
  .selectFrom('users')
  .select(['id', 'email'])
  .execute();

// With conditions
const activeUsers = await context.db
  .selectFrom('users')
  .where('status', '=', 'active')
  .where('created_at', '>', '2024-01-01')
  .orderBy('created_at', 'desc')
  .limit(10)
  .execute();
```

### Insert Queries

```typescript
// Insert single row
const user = await context.db
  .insertInto('users')
  .values({
    id: crypto.randomUUID(),
    email: 'user@example.com',
    name: 'John Doe',
    password_hash: hashedPassword,
  })
  .returning(['id', 'email', 'name'])
  .executeTakeFirst();

// Insert multiple rows
await context.db
  .insertInto('tags')
  .values([
    { id: '1', name: 'javascript' },
    { id: '2', name: 'typescript' },
    { id: '3', name: 'cloudflare' },
  ])
  .execute();
```

### Update Queries

```typescript
// Update by ID
const updated = await context.db
  .updateTable('users')
  .set({
    name: 'Jane Doe',
    updated_at: new Date().toISOString(),
  })
  .where('id', '=', userId)
  .returning(['id', 'name', 'email'])
  .executeTakeFirst();

// Conditional update
await context.db
  .updateTable('posts')
  .set({ status: 'published' })
  .where('author_id', '=', userId)
  .where('status', '=', 'draft')
  .execute();
```

### Delete Queries

```typescript
// Delete by ID
await context.db
  .deleteFrom('users')
  .where('id', '=', userId)
  .execute();

// Delete with conditions
await context.db
  .deleteFrom('sessions')
  .where('expires_at', '<', new Date().toISOString())
  .execute();
```

## Relationships

### Joining Tables

```typescript
// Inner join
const postsWithAuthors = await context.db
  .selectFrom('posts')
  .innerJoin('users', 'users.id', 'posts.author_id')
  .select([
    'posts.id',
    'posts.title',
    'posts.content',
    'users.name as authorName',
    'users.email as authorEmail',
  ])
  .execute();

// Left join
const usersWithPosts = await context.db
  .selectFrom('users')
  .leftJoin('posts', 'posts.author_id', 'users.id')
  .select([
    'users.id',
    'users.name',
    'posts.title as postTitle',
  ])
  .execute();
```

### Subqueries

```typescript
// Users with post count
const usersWithCounts = await context.db
  .selectFrom('users')
  .select([
    'users.id',
    'users.name',
    context.db
      .selectFrom('posts')
      .whereRef('posts.author_id', '=', 'users.id')
      .select(context.db.fn.count('id').as('count'))
      .as('postCount'),
  ])
  .execute();
```

## Transactions

Use transactions for atomic operations:

```typescript
await context.db.transaction(async (trx) => {
  // Create user
  const user = await trx
    .insertInto('users')
    .values({ id: userId, email, name, password_hash: hash })
    .returning(['id'])
    .executeTakeFirstOrThrow();

  // Create profile
  await trx
    .insertInto('profiles')
    .values({ user_id: user.id, bio: '', avatar_url: null })
    .execute();

  // If any query fails, all changes are rolled back
});
```

## Raw SQL

For complex queries, use raw SQL:

```typescript
// Raw query
const results = await context.db.raw`
  SELECT
    strftime('%Y-%m', created_at) as month,
    COUNT(*) as count
  FROM posts
  WHERE author_id = ${userId}
  GROUP BY month
  ORDER BY month DESC
`.execute();

// With typed results
interface MonthlyStats {
  month: string;
  count: number;
}

const stats = await context.db.raw<MonthlyStats>`
  SELECT strftime('%Y-%m', created_at) as month, COUNT(*) as count
  FROM posts
  GROUP BY month
`.execute();
```

## TypeScript Support

### Define Your Schema

```typescript
// lib/db/schema.ts
import type { Generated, Insertable, Selectable, Updateable } from '@cloudwerk/core';

export interface Database {
  users: UsersTable;
  posts: PostsTable;
  comments: CommentsTable;
}

interface UsersTable {
  id: string;
  email: string;
  name: string;
  password_hash: string;
  created_at: Generated<string>;
  updated_at: Generated<string>;
}

export type User = Selectable<UsersTable>;
export type NewUser = Insertable<UsersTable>;
export type UserUpdate = Updateable<UsersTable>;

interface PostsTable {
  id: string;
  title: string;
  content: string;
  author_id: string;
  status: 'draft' | 'published';
  created_at: Generated<string>;
  updated_at: Generated<string>;
}

export type Post = Selectable<PostsTable>;
export type NewPost = Insertable<PostsTable>;
export type PostUpdate = Updateable<PostsTable>;
```

### Configure Type-Safe Database

```typescript
// cloudwerk.config.ts
import { defineConfig } from '@cloudwerk/core';
import type { Database } from './lib/db/schema';

export default defineConfig({
  database: {
    binding: 'DB',
    schema: {} as Database, // Type inference
  },
});
```

Now your queries are fully typed:

```typescript
// Type error: 'invalid_column' does not exist
const users = await context.db
  .selectFrom('users')
  .select(['invalid_column']) // Error!
  .execute();

// Type error: missing required field
await context.db
  .insertInto('users')
  .values({ name: 'John' }) // Error: missing email, password_hash
  .execute();
```

## Best Practices

<Aside type="tip" title="Performance Tips">
- Use indexes for frequently queried columns
- Limit result sets with `.limit()` and pagination
- Use `.select()` to fetch only needed columns
- Batch inserts when possible
- Use transactions for related operations
</Aside>

### Pagination

```typescript
const PAGE_SIZE = 20;

export async function loader({ request, context }: LoaderArgs) {
  const url = new URL(request.url);
  const page = parseInt(url.searchParams.get('page') ?? '1');
  const offset = (page - 1) * PAGE_SIZE;

  const [users, countResult] = await Promise.all([
    context.db
      .selectFrom('users')
      .orderBy('created_at', 'desc')
      .limit(PAGE_SIZE)
      .offset(offset)
      .execute(),
    context.db
      .selectFrom('users')
      .select(context.db.fn.count('id').as('total'))
      .executeTakeFirst(),
  ]);

  return {
    users,
    pagination: {
      page,
      pageSize: PAGE_SIZE,
      total: countResult?.total ?? 0,
      totalPages: Math.ceil((countResult?.total ?? 0) / PAGE_SIZE),
    },
  };
}
```

## Next Steps

- **[Queues Guide](/guides/queues/)** - Background job processing
- **[Storage Guide](/api/bindings/)** - KV and R2 storage
- **[API Reference](/api/context/)** - Database context API
