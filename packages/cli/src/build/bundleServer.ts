/**
 * @cloudwerk/cli - Server Bundler
 *
 * Bundles the Hono app with all routes into a single Worker-compatible file.
 * Uses esbuild configured for Cloudflare Workers (platform: neutral).
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import { build, type BuildResult as EsbuildResult, type Plugin } from 'esbuild'
import { gzipSync } from 'node:zlib'
import type { RouteManifest, CloudwerkConfig } from '@cloudwerk/core'
import { generateWorkerEntry } from './generateWorkerEntry.js'
import type { Logger, ServerBundleResult } from '../types.js'

// ============================================================================
// Types
// ============================================================================

/**
 * Options for server bundling.
 */
export interface BundleServerOptions {
  /** Route manifest */
  manifest: RouteManifest
  /** Cloudwerk configuration */
  config: CloudwerkConfig
  /** Output directory (dist/) */
  outputDir: string
  /** Routes directory (absolute path) */
  routesDir: string
  /** Enable minification */
  minify?: boolean
  /** Enable source maps */
  sourcemap?: boolean
  /** Logger for output */
  logger: Logger
  /** Enable verbose logging */
  verbose?: boolean
}

// ============================================================================
// Constants
// ============================================================================

/** Output file name for the Worker bundle */
const WORKER_OUTPUT_FILE = 'index.js'

/** Temporary build directory name */
const BUILD_TEMP_DIR = '.build'

/** Bundle size warning threshold (1MB uncompressed) */
const SIZE_WARNING_THRESHOLD = 1024 * 1024

/** Cloudflare Workers compressed size limit (10MB) */
const CF_COMPRESSED_LIMIT = 10 * 1024 * 1024

// ============================================================================
// Server Bundling
// ============================================================================

/**
 * Bundle the server application for Cloudflare Workers.
 *
 * This function:
 * 1. Generates a virtual entry point with all routes
 * 2. Bundles everything with esbuild for Workers
 * 3. Outputs a single Worker-compatible file
 *
 * @param options - Bundling options
 * @returns Bundle result with path and sizes
 *
 * @example
 * ```typescript
 * const result = await bundleServer({
 *   manifest,
 *   config,
 *   outputDir: './dist',
 *   routesDir: './app/routes',
 *   minify: true,
 *   logger,
 * })
 * console.log(`Server bundle: ${result.size} bytes`)
 * ```
 */
export async function bundleServer(
  options: BundleServerOptions
): Promise<ServerBundleResult> {
  const {
    manifest,
    config,
    outputDir,
    routesDir,
    minify = true,
    sourcemap = false,
    logger,
    verbose = false,
  } = options

  logger.info('Bundling server...')

  // Create temp directory for generated entry point
  const tempDir = path.join(outputDir, BUILD_TEMP_DIR)
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true })
  }

  try {
    // Step 1: Generate the worker entry point
    logger.debug('Generating worker entry point...')
    const { entryPath } = await generateWorkerEntry({
      manifest,
      config,
      outputDir: tempDir,
      routesDir,
      staticAssets: true,
    })

    if (verbose) {
      logger.debug(`Generated entry point: ${entryPath}`)
    }

    // Step 2: Bundle with esbuild
    const outputPath = path.join(outputDir, WORKER_OUTPUT_FILE)

    logger.debug('Running esbuild...')
    const result = await build({
      entryPoints: [entryPath],
      bundle: true,
      write: true,
      outfile: outputPath,
      format: 'esm',
      platform: 'neutral', // Cloudflare Workers compatible
      target: ['es2022'],
      minify,
      sourcemap: sourcemap ? 'linked' : false,
      treeShaking: true,
      logLevel: verbose ? 'info' : 'silent',
      // Keep size analysis metadata
      metafile: true,
      // Define environment
      define: {
        'process.env.NODE_ENV': JSON.stringify('production'),
      },
      // Plugin to stub out Node.js built-ins and build-time-only packages for Workers
      plugins: [
        createNodeBuiltinsPlugin(),
      ],
      // Resolve JSX correctly
      jsx: 'automatic',
      jsxImportSource: config.ui?.renderer === 'react' ? 'react' : 'hono/jsx',
      // Avoid issues with __dirname/__filename
      banner: {
        js: '// Generated by cloudwerk build\n',
      },
    })

    // Step 3: Calculate sizes
    const stat = fs.statSync(outputPath)
    const size = stat.size
    const content = fs.readFileSync(outputPath)
    const compressed = gzipSync(content)
    const compressedSize = compressed.length

    // Log size information
    logger.info(`Server bundle: ${formatSize(size)} (${formatSize(compressedSize)} gzipped)`)

    // Warn if bundle is large
    if (size > SIZE_WARNING_THRESHOLD) {
      logger.warn(`Warning: Server bundle exceeds ${formatSize(SIZE_WARNING_THRESHOLD)}`)
      if (result.metafile) {
        logLargestModules(result, logger)
      }
    }

    // Error if exceeding Cloudflare limits
    if (compressedSize > CF_COMPRESSED_LIMIT) {
      logger.error(`Error: Compressed bundle (${formatSize(compressedSize)}) exceeds Cloudflare Workers limit of ${formatSize(CF_COMPRESSED_LIMIT)}`)
    }

    if (verbose && result.metafile) {
      logBundleAnalysis(result.metafile, logger)
    }

    return {
      outputPath,
      size,
      compressedSize,
    }
  } finally {
    // Cleanup temp directory
    try {
      fs.rmSync(tempDir, { recursive: true, force: true })
    } catch {
      // Ignore cleanup errors
    }
  }
}

// ============================================================================
// Esbuild Plugins
// ============================================================================

/**
 * Create an esbuild plugin that stubs out Node.js built-ins and
 * build-time-only packages for Cloudflare Workers compatibility.
 *
 * These modules are used at build time (scanner, config loader) but
 * should not be included in the production bundle.
 *
 * @returns esbuild plugin
 */
function createNodeBuiltinsPlugin(): Plugin {
  // Node.js built-in modules that should be stubbed
  const nodeBuiltins = [
    'fs', 'path', 'url', 'util', 'crypto', 'stream',
    'async_hooks', 'os', 'child_process', 'module',
  ]

  // Build-time-only packages that should be stubbed
  const buildTimePackages = [
    'fast-glob',
    'esbuild',
  ]

  return {
    name: 'cloudwerk-node-builtins-stub',
    setup(build) {
      // Handle Node.js built-ins (both with and without node: prefix)
      for (const name of nodeBuiltins) {
        // Plain import: 'fs'
        build.onResolve({ filter: new RegExp(`^${name}$`) }, () => ({
          path: name,
          namespace: 'node-builtin-stub',
        }))
        // Prefixed import: 'node:fs'
        build.onResolve({ filter: new RegExp(`^node:${name}$`) }, () => ({
          path: name,
          namespace: 'node-builtin-stub',
        }))
      }

      // Handle build-time packages
      for (const name of buildTimePackages) {
        build.onResolve({ filter: new RegExp(`^${name}$`) }, () => ({
          path: name,
          namespace: 'node-builtin-stub',
        }))
      }

      // Provide stub module with common exports for all stubbed imports
      build.onLoad({ filter: /.*/, namespace: 'node-builtin-stub' }, (args) => {
        // Provide stubs for commonly used exports
        // These will throw at runtime if actually called, which is intentional -
        // they shouldn't be called in production, only at build time
        const stubFn = '(...args) => { throw new Error(`Build-time only: ${args.path} should not be called in production`) }'

        let contents = `
          // Stubbed module for Cloudflare Workers compatibility
          // Module: ${args.path}
          const notImplemented = ${stubFn};
          export default {};
          export const __esModule = true;
        `

        // Add specific named exports based on the module
        if (args.path === 'url') {
          contents += `
            export const pathToFileURL = notImplemented;
            export const fileURLToPath = notImplemented;
            export const URL = globalThis.URL;
          `
        } else if (args.path === 'esbuild' || args.path === 'fast-glob') {
          contents += `
            export const build = notImplemented;
            export const sync = notImplemented;
          `
        } else if (args.path === 'async_hooks') {
          // AsyncLocalStorage is used by context.ts - we need a working implementation
          contents = `
            // AsyncLocalStorage polyfill for Workers
            // Workers have AsyncLocalStorage built-in via workerd
            export class AsyncLocalStorage {
              #store = undefined;
              run(store, callback, ...args) {
                const prev = this.#store;
                this.#store = store;
                try {
                  return callback(...args);
                } finally {
                  this.#store = prev;
                }
              }
              getStore() {
                return this.#store;
              }
            }
            export default { AsyncLocalStorage };
          `
        } else if (args.path === 'fs') {
          contents += `
            export const readFileSync = notImplemented;
            export const writeFileSync = notImplemented;
            export const existsSync = () => false;
            export const statSync = notImplemented;
            export const readdirSync = notImplemented;
            export const mkdirSync = notImplemented;
            export const unlinkSync = notImplemented;
            export const rmSync = notImplemented;
            export const promises = {
              readFile: notImplemented,
              writeFile: notImplemented,
              readdir: notImplemented,
              stat: notImplemented,
              mkdir: notImplemented,
              unlink: notImplemented,
              rm: notImplemented,
            };
          `
        } else if (args.path === 'path') {
          contents += `
            export const join = (...parts) => parts.join('/').replace(/\\/\\/+/g, '/');
            export const dirname = (p) => p.split('/').slice(0, -1).join('/') || '/';
            export const basename = (p) => p.split('/').pop() || '';
            export const extname = (p) => { const m = p.match(/\\.[^.]+$/); return m ? m[0] : ''; };
            export const resolve = (...parts) => parts.join('/').replace(/\\/\\/+/g, '/');
            export const relative = (from, to) => to;
            export const isAbsolute = (p) => p.startsWith('/');
            export const sep = '/';
          `
        }

        return { contents, loader: 'js' }
      })
    },
  }
}

// ============================================================================
// Bundle Analysis
// ============================================================================

/**
 * Log the largest modules in the bundle.
 *
 * @param result - esbuild build result
 * @param logger - Logger for output
 */
function logLargestModules(result: EsbuildResult, logger: Logger): void {
  if (!result.metafile) return

  const inputs = result.metafile.inputs
  const modules = Object.entries(inputs)
    .map(([name, info]) => ({ name, size: info.bytes }))
    .sort((a, b) => b.size - a.size)
    .slice(0, 5)

  logger.warn('Largest modules:')
  for (const mod of modules) {
    logger.warn(`  ${formatSize(mod.size).padStart(10)} ${shortenPath(mod.name)}`)
  }
}

/**
 * Log detailed bundle analysis.
 *
 * @param metafile - esbuild metafile
 * @param logger - Logger for output
 */
function logBundleAnalysis(
  metafile: NonNullable<EsbuildResult['metafile']>,
  logger: Logger
): void {
  const inputs = metafile.inputs
  const totalSize = Object.values(inputs).reduce((sum, info) => sum + info.bytes, 0)
  const moduleCount = Object.keys(inputs).length

  logger.debug('')
  logger.debug('Bundle Analysis:')
  logger.debug(`  Total modules: ${moduleCount}`)
  logger.debug(`  Total input size: ${formatSize(totalSize)}`)

  // Group by package
  const packageSizes = new Map<string, number>()
  for (const [name, info] of Object.entries(inputs)) {
    const pkg = extractPackageName(name)
    const current = packageSizes.get(pkg) || 0
    packageSizes.set(pkg, current + info.bytes)
  }

  const sortedPackages = Array.from(packageSizes.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)

  logger.debug('')
  logger.debug('Top packages by size:')
  for (const [pkg, size] of sortedPackages) {
    logger.debug(`  ${formatSize(size).padStart(10)} ${pkg}`)
  }
}

/**
 * Extract package name from a module path.
 *
 * @param modulePath - Module path
 * @returns Package name or "app" for local modules
 */
function extractPackageName(modulePath: string): string {
  // node_modules/package-name/... or node_modules/@scope/package-name/...
  const match = modulePath.match(/node_modules\/(@[^/]+\/[^/]+|[^/]+)/)
  if (match) {
    return match[1]
  }
  // Local module
  if (modulePath.includes('/app/') || modulePath.includes('/routes/')) {
    return 'app (local)'
  }
  return 'other'
}

// ============================================================================
// Utilities
// ============================================================================

/**
 * Format a byte size for human-readable display.
 *
 * @param bytes - Size in bytes
 * @returns Formatted size string (e.g., "14.2 KB")
 */
function formatSize(bytes: number): string {
  if (bytes < 1024) {
    return `${bytes} B`
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)} KB`
  }
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`
}

/**
 * Shorten a file path for display.
 *
 * @param filePath - Full file path
 * @returns Shortened path
 */
function shortenPath(filePath: string): string {
  // Remove node_modules prefix for cleaner display
  const parts = filePath.split('node_modules/')
  if (parts.length > 1) {
    return `node_modules/${parts[parts.length - 1]}`
  }
  // Show last 3 path components
  const segments = filePath.split('/')
  return segments.slice(-3).join('/')
}
