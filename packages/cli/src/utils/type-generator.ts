/**
 * @cloudwerk/cli - Cloudwerk Type Generator
 *
 * Generates TypeScript type declarations for @cloudwerk/core/bindings
 * and @cloudwerk/core/context modules based on wrangler.toml bindings.
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import type { Binding, BindingType } from './wrangler-toml.js'
import { getTypeForBinding } from './env-types.js'

// ============================================================================
// Constants
// ============================================================================

const CLOUDWERK_TYPES_DIR = '.cloudwerk/types'
const BINDINGS_DTS = 'bindings.d.ts'
const CONTEXT_DTS = 'context.d.ts'

// ============================================================================
// Types
// ============================================================================

export interface GenerateCloudwerkTypesOptions {
  /** Include timestamp in generated files */
  includeTimestamp?: boolean
}

export interface GenerateCloudwerkTypesResult {
  /** Path to the generated types directory */
  typesDir: string
  /** Paths to generated files */
  files: {
    bindings: string
    context: string
  }
  /** Number of bindings included */
  bindingCount: number
  /** List of bindings with their types */
  bindings: Array<{ name: string; type: string }>
}

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Generate .cloudwerk/types/ directory with module declarations.
 *
 * Creates:
 * - bindings.d.ts - Module declaration for @cloudwerk/core/bindings
 * - context.d.ts - Module declaration for @cloudwerk/core/context
 */
export function generateCloudwerkTypes(
  cwd: string,
  bindings: Binding[],
  options: GenerateCloudwerkTypesOptions = {}
): GenerateCloudwerkTypesResult {
  const includeTimestamp = options.includeTimestamp ?? true
  const typesDir = path.join(cwd, CLOUDWERK_TYPES_DIR)

  // Ensure directory exists
  fs.mkdirSync(typesDir, { recursive: true })

  // Generate bindings.d.ts
  const bindingsPath = path.join(typesDir, BINDINGS_DTS)
  const bindingsContent = generateBindingsDts(bindings, includeTimestamp)
  fs.writeFileSync(bindingsPath, bindingsContent, 'utf-8')

  // Generate context.d.ts
  const contextPath = path.join(typesDir, CONTEXT_DTS)
  const contextContent = generateContextDts(bindings, includeTimestamp)
  fs.writeFileSync(contextPath, contextContent, 'utf-8')

  // Collect binding info for result
  const bindingInfo = bindings.map((b) => ({
    name: b.name,
    type: getTypeForBinding(b.type),
  }))

  return {
    typesDir,
    files: {
      bindings: bindingsPath,
      context: contextPath,
    },
    bindingCount: bindings.length,
    bindings: bindingInfo,
  }
}

/**
 * Generate bindings.d.ts content.
 */
function generateBindingsDts(bindings: Binding[], includeTimestamp: boolean): string {
  const lines: string[] = []

  // Header
  lines.push('// Auto-generated by cloudwerk bindings - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`// Last updated: ${new Date().toISOString()}`)
  }
  lines.push('//')
  lines.push('// This file provides type information for @cloudwerk/core/bindings')
  lines.push('// Add ".cloudwerk/types" to your tsconfig.json include array')
  lines.push('')

  // Module declaration
  lines.push("declare module '@cloudwerk/core/bindings' {")

  // Group bindings by type for organized output
  const bindingsByType = groupBindingsByType(bindings)
  const typeOrder: BindingType[] = [
    'd1',
    'kv',
    'r2',
    'queue',
    'do',
    'service',
    'ai',
    'vectorize',
    'hyperdrive',
    'secret',
  ]

  // Generate individual binding exports
  let firstSection = true
  for (const type of typeOrder) {
    const typeBindings = bindingsByType.get(type)
    if (!typeBindings || typeBindings.length === 0) continue

    const tsType = getTypeForBinding(type)
    const sectionName = getSectionName(type)

    if (!firstSection) {
      lines.push('')
    }
    lines.push(`  // ${sectionName}`)
    firstSection = false

    for (const binding of typeBindings) {
      lines.push(`  export const ${binding.name}: ${tsType}`)
    }
  }

  // Add bindings proxy export
  lines.push('')
  lines.push('  // Bindings proxy object (for dynamic access)')
  lines.push('  export const bindings: Record<string, unknown>')
  lines.push('')

  // Add helper functions
  lines.push('  // Helper functions')
  lines.push('  export function getBinding<T = unknown>(name: string): T')
  lines.push('  export function hasBinding(name: string): boolean')
  lines.push('  export function getBindingNames(): string[]')

  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate context.d.ts content.
 */
function generateContextDts(bindings: Binding[], includeTimestamp: boolean): string {
  const lines: string[] = []

  // Header
  lines.push('// Auto-generated by cloudwerk bindings - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`// Last updated: ${new Date().toISOString()}`)
  }
  lines.push('//')
  lines.push('// This file provides type information for @cloudwerk/core/context')
  lines.push('// Add ".cloudwerk/types" to your tsconfig.json include array')
  lines.push('')

  // Build Env interface for typed env access
  lines.push('interface CloudwerkEnv {')

  const bindingsByType = groupBindingsByType(bindings)
  const typeOrder: BindingType[] = [
    'd1',
    'kv',
    'r2',
    'queue',
    'do',
    'service',
    'ai',
    'vectorize',
    'hyperdrive',
    'secret',
  ]

  let firstSection = true
  for (const type of typeOrder) {
    const typeBindings = bindingsByType.get(type)
    if (!typeBindings || typeBindings.length === 0) continue

    const tsType = getTypeForBinding(type)
    const sectionName = getSectionName(type)

    if (!firstSection) {
      lines.push('')
    }
    lines.push(`  // ${sectionName}`)
    firstSection = false

    for (const binding of typeBindings) {
      lines.push(`  ${binding.name}: ${tsType}`)
    }
  }

  lines.push('}')
  lines.push('')

  // Module declaration
  lines.push("declare module '@cloudwerk/core/context' {")
  lines.push('  // Route parameters proxy')
  lines.push('  export const params: Record<string, string>')
  lines.push('')
  lines.push('  // Current request proxy')
  lines.push('  export const request: Request')
  lines.push('')
  lines.push('  // Environment bindings proxy (typed from wrangler.toml)')
  lines.push('  export const env: CloudwerkEnv')
  lines.push('')
  lines.push('  // Cloudflare execution context proxy')
  lines.push('  export const executionCtx: {')
  lines.push('    waitUntil(promise: Promise<unknown>): void')
  lines.push('    passThroughOnException(): void')
  lines.push('  }')
  lines.push('')
  lines.push('  // Helper functions')
  lines.push('  export function getRequestId(): string')
  lines.push('  export function get<T>(key: string): T | undefined')
  lines.push('  export function set<T>(key: string, value: T): void')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Group bindings by type.
 */
function groupBindingsByType(bindings: Binding[]): Map<BindingType, Binding[]> {
  const grouped = new Map<BindingType, Binding[]>()

  for (const binding of bindings) {
    const existing = grouped.get(binding.type) || []
    existing.push(binding)
    grouped.set(binding.type, existing)
  }

  return grouped
}

/**
 * Get section name for a binding type.
 */
function getSectionName(type: BindingType): string {
  switch (type) {
    case 'd1':
      return 'D1 Databases'
    case 'kv':
      return 'KV Namespaces'
    case 'r2':
      return 'R2 Buckets'
    case 'queue':
      return 'Queues'
    case 'do':
      return 'Durable Objects'
    case 'service':
      return 'Services'
    case 'secret':
      return 'Environment Variables'
    case 'ai':
      return 'AI'
    case 'vectorize':
      return 'Vectorize Indexes'
    case 'hyperdrive':
      return 'Hyperdrive'
    default:
      return 'Other'
  }
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if .cloudwerk/types/ exists.
 */
export function cloudwerkTypesExist(cwd: string): boolean {
  const typesDir = path.join(cwd, CLOUDWERK_TYPES_DIR)
  return fs.existsSync(typesDir)
}

/**
 * Delete .cloudwerk/types/ directory.
 */
export function deleteCloudwerkTypes(cwd: string): boolean {
  const typesDir = path.join(cwd, CLOUDWERK_TYPES_DIR)
  if (fs.existsSync(typesDir)) {
    fs.rmSync(typesDir, { recursive: true })
    return true
  }
  return false
}

/**
 * Get path to .cloudwerk/types/ directory.
 */
export function getCloudwerkTypesDir(cwd: string): string {
  return path.join(cwd, CLOUDWERK_TYPES_DIR)
}
