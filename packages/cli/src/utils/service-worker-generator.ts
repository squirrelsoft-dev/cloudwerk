/**
 * @cloudwerk/cli - Service Worker Generator
 *
 * Generates WorkerEntrypoint wrapper classes for extracted services.
 * These wrappers enable Cloudflare's native RPC for service bindings.
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import type { ServiceEntry, ServiceManifest } from '@cloudwerk/core/build'

// ============================================================================
// Constants
// ============================================================================

const EXTRACTED_DIR = '.cloudwerk/extracted'

// ============================================================================
// Types
// ============================================================================

export interface GenerateServiceWorkerOptions {
  /** Include timestamp in generated files */
  includeTimestamp?: boolean
}

export interface GenerateServiceWorkerResult {
  /** Path to the generated worker directory */
  workerDir: string
  /** Path to the generated worker file */
  workerFile: string
  /** Path to the generated wrangler.toml */
  wranglerFile: string
  /** Service entry this was generated for */
  service: ServiceEntry
}

export interface GenerateAllServiceWorkersResult {
  /** Directory containing all extracted workers */
  extractedDir: string
  /** Results for each generated worker */
  workers: GenerateServiceWorkerResult[]
  /** Number of workers generated */
  count: number
}

// ============================================================================
// Worker Generation
// ============================================================================

/**
 * Generate a WorkerEntrypoint wrapper for an extracted service.
 *
 * Creates:
 * - .cloudwerk/extracted/<service-name>/worker.ts
 * - .cloudwerk/extracted/<service-name>/wrangler.toml
 */
export function generateServiceWorker(
  cwd: string,
  service: ServiceEntry,
  options: GenerateServiceWorkerOptions = {}
): GenerateServiceWorkerResult {
  const includeTimestamp = options.includeTimestamp ?? true
  const workerDir = path.join(cwd, EXTRACTED_DIR, service.workerName)

  // Ensure directory exists
  fs.mkdirSync(workerDir, { recursive: true })

  // Generate worker.ts
  const workerPath = path.join(workerDir, 'worker.ts')
  const workerContent = generateWorkerEntrypoint(cwd, service, includeTimestamp)
  fs.writeFileSync(workerPath, workerContent, 'utf-8')

  // Generate wrangler.toml
  const wranglerPath = path.join(workerDir, 'wrangler.toml')
  const wranglerContent = generateWorkerWranglerToml(service, includeTimestamp)
  fs.writeFileSync(wranglerPath, wranglerContent, 'utf-8')

  return {
    workerDir,
    workerFile: workerPath,
    wranglerFile: wranglerPath,
    service,
  }
}

/**
 * Generate WorkerEntrypoint wrappers for all extracted services.
 */
export function generateAllServiceWorkers(
  cwd: string,
  manifest: ServiceManifest,
  options: GenerateServiceWorkerOptions = {}
): GenerateAllServiceWorkersResult {
  const extractedDir = path.join(cwd, EXTRACTED_DIR)

  // Only generate for extracted services
  const extractedServices = manifest.services.filter((s) => s.mode === 'extracted')

  const workers: GenerateServiceWorkerResult[] = []
  for (const service of extractedServices) {
    const result = generateServiceWorker(cwd, service, options)
    workers.push(result)
  }

  return {
    extractedDir,
    workers,
    count: workers.length,
  }
}

/**
 * Generate the WorkerEntrypoint class content.
 */
function generateWorkerEntrypoint(
  cwd: string,
  service: ServiceEntry,
  includeTimestamp: boolean
): string {
  const lines: string[] = []

  // Calculate relative path from worker to service definition
  const workerDir = path.join(cwd, EXTRACTED_DIR, service.workerName)
  const relativePath = path.relative(workerDir, service.absolutePath)
    .replace(/\\/g, '/') // Windows compatibility
    .replace(/\.tsx?$/, '') // Remove extension for import

  // Header
  lines.push('// Auto-generated by cloudwerk services - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`// Last updated: ${new Date().toISOString()}`)
  }
  lines.push('//')
  lines.push(`// WorkerEntrypoint wrapper for ${service.name} service`)
  lines.push(`// Source: ${service.filePath}`)
  lines.push('')

  // Imports
  lines.push("import { WorkerEntrypoint } from 'cloudflare:workers'")
  lines.push(`import service from '${relativePath}'`)
  lines.push('')

  // Env interface
  lines.push('// Environment bindings for this service')
  lines.push('interface Env {')
  if (service.requiredBindings.length > 0) {
    for (const binding of service.requiredBindings) {
      lines.push(`  ${binding}: unknown`)
    }
  } else {
    lines.push('  // Add binding types here')
  }
  lines.push('}')
  lines.push('')

  // WorkerEntrypoint class
  lines.push('/**')
  lines.push(` * ${service.entrypointClass} - WorkerEntrypoint for ${service.name} service`)
  lines.push(' *')
  lines.push(' * This class wraps the service methods and handles lifecycle hooks.')
  lines.push(' * Cloudflare\'s service binding RPC will call methods directly on this class.')
  lines.push(' */')
  lines.push(`export class ${service.entrypointClass} extends WorkerEntrypoint<Env> {`)
  lines.push('  private initialized = false')
  lines.push('')

  // Initialization method
  lines.push('  /**')
  lines.push('   * Initialize the service (runs onInit hook once).')
  lines.push('   */')
  lines.push('  private async ensureInitialized(): Promise<void> {')
  lines.push('    if (this.initialized) return')
  lines.push('    this.initialized = true')
  lines.push('')
  lines.push('    if (service.hooks?.onInit) {')
  lines.push('      await service.hooks.onInit()')
  lines.push('    }')
  lines.push('  }')
  lines.push('')

  // Generate method wrappers
  if (service.methodNames.length > 0) {
    for (const methodName of service.methodNames) {
      lines.push(`  /**`)
      lines.push(`   * ${methodName} - wrapped service method`)
      lines.push('   */')
      lines.push(`  async ${methodName}(...args: unknown[]): Promise<unknown> {`)
      lines.push('    await this.ensureInitialized()')
      lines.push('')
      lines.push('    // Run onBefore hook')
      lines.push('    if (service.hooks?.onBefore) {')
      lines.push(`      await service.hooks.onBefore('${methodName}', args)`)
      lines.push('    }')
      lines.push('')
      lines.push('    try {')
      lines.push('      // Call the actual service method')
      lines.push(`      const method = service.methods.${methodName}`)
      lines.push('      const result = await method.apply({ env: this.env }, args)')
      lines.push('')
      lines.push('      // Run onAfter hook')
      lines.push('      if (service.hooks?.onAfter) {')
      lines.push(`        await service.hooks.onAfter('${methodName}', result)`)
      lines.push('      }')
      lines.push('')
      lines.push('      return result')
      lines.push('    } catch (error) {')
      lines.push('      // Run onError hook')
      lines.push('      if (service.hooks?.onError) {')
      lines.push(`        await service.hooks.onError('${methodName}', error as Error)`)
      lines.push('      }')
      lines.push('      throw error')
      lines.push('    }')
      lines.push('  }')
      lines.push('')
    }
  } else {
    // Fallback for when we don't know method names yet
    lines.push('  // Method wrappers will be generated once service is loaded')
    lines.push('  // Run `cloudwerk services extract` after defining methods')
    lines.push('')
  }

  lines.push('}')
  lines.push('')

  // Default export with fetch handler
  lines.push('// Default export for direct worker access')
  lines.push('export default {')
  lines.push('  async fetch(): Promise<Response> {')
  lines.push(`    return new Response('${service.name} service is running. Use service binding RPC to call methods.')`)
  lines.push('  },')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate wrangler.toml for an extracted service worker.
 */
function generateWorkerWranglerToml(
  service: ServiceEntry,
  includeTimestamp: boolean
): string {
  const lines: string[] = []

  // Header
  lines.push('# Auto-generated by cloudwerk services - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`# Last updated: ${new Date().toISOString()}`)
  }
  lines.push('#')
  lines.push(`# Wrangler configuration for ${service.name} service`)
  lines.push(`# Source: ${service.filePath}`)
  lines.push('')

  // Worker configuration
  lines.push(`name = "${service.workerName}"`)
  lines.push('main = "worker.ts"')
  lines.push('compatibility_date = "2024-09-23"')
  lines.push('')

  // Bindings needed by this service
  if (service.requiredBindings.length > 0) {
    lines.push('# Bindings required by this service')
    lines.push('# Update these with your actual binding configurations')
    lines.push('')

    for (const binding of service.requiredBindings) {
      // Try to guess the binding type from the name
      if (binding.includes('DB') || binding.includes('D1')) {
        lines.push('[[d1_databases]]')
        lines.push(`binding = "${binding}"`)
        lines.push(`database_name = "\${${binding}_NAME}"`)
        lines.push(`database_id = "\${${binding}_ID}"`)
      } else if (binding.includes('KV') || binding.includes('CACHE')) {
        lines.push('[[kv_namespaces]]')
        lines.push(`binding = "${binding}"`)
        lines.push(`id = "\${${binding}_ID}"`)
      } else if (binding.includes('R2') || binding.includes('BUCKET') || binding.includes('STORAGE')) {
        lines.push('[[r2_buckets]]')
        lines.push(`binding = "${binding}"`)
        lines.push(`bucket_name = "\${${binding}_NAME}"`)
      } else if (binding.includes('QUEUE')) {
        lines.push('[[queues.producers]]')
        lines.push(`queue = "\${${binding}_NAME}"`)
        lines.push(`binding = "${binding}"`)
      } else {
        // Default to var for secrets/environment variables
        lines.push('[vars]')
        lines.push(`# ${binding} = "..."`)
      }
      lines.push('')
    }
  } else {
    lines.push('# No bindings configured')
    lines.push('# Add bindings in your service definition:')
    lines.push('#   config: {')
    lines.push('#     extraction: {')
    lines.push("#       bindings: ['DB', 'CACHE'],")
    lines.push('#     }')
    lines.push('#   }')
    lines.push('')
  }

  return lines.join('\n')
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if a service worker directory exists.
 */
export function serviceWorkerExists(cwd: string, serviceName: string): boolean {
  const workerDir = path.join(cwd, EXTRACTED_DIR, `${serviceName}-service`)
  return fs.existsSync(workerDir)
}

/**
 * Delete a service worker directory.
 */
export function deleteServiceWorker(cwd: string, serviceName: string): boolean {
  const workerDir = path.join(cwd, EXTRACTED_DIR, `${serviceName}-service`)
  if (fs.existsSync(workerDir)) {
    fs.rmSync(workerDir, { recursive: true, force: true })
    return true
  }
  return false
}

/**
 * Get path to extracted workers directory.
 */
export function getExtractedDir(cwd: string): string {
  return path.join(cwd, EXTRACTED_DIR)
}

/**
 * Get all extracted service worker directories.
 */
export function getExtractedServiceDirs(cwd: string): string[] {
  const extractedDir = path.join(cwd, EXTRACTED_DIR)
  if (!fs.existsSync(extractedDir)) {
    return []
  }

  return fs.readdirSync(extractedDir)
    .map((name) => path.join(extractedDir, name))
    .filter((p) => fs.statSync(p).isDirectory())
}
