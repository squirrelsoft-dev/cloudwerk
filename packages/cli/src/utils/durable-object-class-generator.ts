/**
 * @cloudwerk/cli - Durable Object Class Generator
 *
 * Generates Cloudflare DurableObject classes from defineDurableObject() definitions.
 * The generated classes extend Cloudflare's native DurableObject and expose
 * methods as native RPC methods (no HTTP overhead).
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import type { DurableObjectEntry, DurableObjectManifest } from '@cloudwerk/core/build'

// ============================================================================
// Types
// ============================================================================

export interface GenerateDOClassOptions {
  /** Output directory for generated files */
  outputDir?: string
  /** Include comments in generated code */
  includeComments?: boolean
  /** Dry run - don't write files */
  dryRun?: boolean
}

export interface GenerateDOClassResult {
  /** Files that were generated */
  generated: Array<{ name: string; className: string; path: string }>
  /** Any errors encountered */
  errors: string[]
  /** Output directory used */
  outputDir: string
}

// ============================================================================
// Code Generation
// ============================================================================

/**
 * Generate the import path from generated file to definition file.
 */
function getRelativeImportPath(
  generatedPath: string,
  definitionPath: string
): string {
  const generatedDir = path.dirname(generatedPath)
  let relativePath = path.relative(generatedDir, definitionPath)

  // Ensure it starts with ./ or ../
  if (!relativePath.startsWith('.') && !relativePath.startsWith('/')) {
    relativePath = './' + relativePath
  }

  // Remove file extension for import
  return relativePath.replace(/\.(ts|tsx|js|jsx)$/, '')
}

/**
 * Generate the DurableObject class code for a single entry.
 */
export function generateDOClassCode(
  entry: DurableObjectEntry,
  includeComments: boolean = true
): string {
  const lines: string[] = []

  // Header comment
  if (includeComments) {
    lines.push('/**')
    lines.push(` * Auto-generated Durable Object class for '${entry.name}'`)
    lines.push(' * ')
    lines.push(' * DO NOT EDIT - This file is generated by Cloudwerk.')
    lines.push(` * Source: app/objects/${entry.filePath}`)
    lines.push(' */')
    lines.push('')
  }

  // Imports
  lines.push("import { DurableObject } from 'cloudflare:workers'")
  lines.push('')

  // Import the definition
  const importPath = getRelativeImportPath(entry.generatedPath, entry.absolutePath)
  lines.push(`import definition from '${importPath}'`)
  lines.push('')

  // Type declarations
  lines.push('// Type for the state managed by this Durable Object')
  lines.push(`type ${entry.className}State = Parameters<NonNullable<typeof definition.config.init>>[0] extends { storage: unknown }`)
  lines.push(`  ? Awaited<ReturnType<NonNullable<typeof definition.config.init>>>`)
  lines.push('  : unknown')
  lines.push('')

  // Interface for context
  lines.push(`interface ${entry.className}Context {`)
  lines.push('  storage: DurableObjectStorage')
  lines.push('  sql: SqlStorage')
  lines.push('  id: DurableObjectId')
  lines.push('  getWebSockets(tag?: string): WebSocket[]')
  lines.push('  acceptWebSocket(ws: WebSocket, tags?: string[]): void')
  lines.push('}')
  lines.push('')

  // Interface for handler context
  lines.push(`interface ${entry.className}HandlerContext {`)
  lines.push(`  state: ${entry.className}State`)
  lines.push(`  ctx: ${entry.className}Context`)
  lines.push('}')
  lines.push('')

  // Class definition
  lines.push(`export class ${entry.className} extends DurableObject<Env> {`)
  lines.push(`  private state: ${entry.className}State | undefined`)
  lines.push('  private initialized = false')
  lines.push('')

  // ensureInit method
  lines.push('  private async ensureInit(): Promise<void> {')
  lines.push('    if (this.initialized) return')
  lines.push('    if (definition.config.init) {')
  lines.push('      this.state = await definition.config.init(this.createContext(), this.env)')
  lines.push('    } else {')
  lines.push(`      this.state = {} as ${entry.className}State`)
  lines.push('    }')
  lines.push('    this.initialized = true')
  lines.push('  }')
  lines.push('')

  // createContext method
  lines.push(`  private createContext(): ${entry.className}Context {`)
  lines.push('    return {')
  lines.push('      storage: this.ctx.storage,')
  lines.push('      sql: this.ctx.storage.sql,')
  lines.push('      id: this.ctx.id,')
  lines.push('      getWebSockets: (tag?: string) => this.ctx.getWebSockets(tag),')
  lines.push('      acceptWebSocket: (ws: WebSocket, tags?: string[]) => this.ctx.acceptWebSocket(ws, tags),')
  lines.push('    }')
  lines.push('  }')
  lines.push('')

  // createHandlerContext method
  lines.push(`  private createHandlerContext(): ${entry.className}HandlerContext {`)
  lines.push('    return {')
  lines.push('      state: this.state!,')
  lines.push('      ctx: this.createContext(),')
  lines.push('    }')
  lines.push('  }')
  lines.push('')

  // Generate RPC methods
  if (entry.methodNames.length > 0) {
    if (includeComments) {
      lines.push('  // RPC methods - directly callable via native Cloudflare RPC')
    }
    for (const methodName of entry.methodNames) {
      lines.push('')
      lines.push(`  async ${methodName}(...args: unknown[]): Promise<unknown> {`)
      lines.push('    await this.ensureInit()')
      lines.push(`    return definition.config.methods!.${methodName}.call(this.createHandlerContext(), ...args)`)
      lines.push('  }')
    }
    lines.push('')
  }

  // fetch handler
  if (includeComments) {
    lines.push('  // HTTP handler')
  }
  lines.push('  async fetch(request: Request): Promise<Response> {')
  lines.push('    await this.ensureInit()')
  lines.push('    if (definition.config.fetch) {')
  lines.push('      return definition.config.fetch.call(this.createHandlerContext(), request, this.env)')
  lines.push('    }')
  lines.push("    return new Response('Not Found', { status: 404 })")
  lines.push('  }')
  lines.push('')

  // alarm handler
  if (entry.hasAlarm) {
    if (includeComments) {
      lines.push('  // Alarm handler')
    }
    lines.push('  async alarm(): Promise<void> {')
    lines.push('    await this.ensureInit()')
    lines.push('    if (definition.config.alarm) {')
    lines.push('      await definition.config.alarm.call(this.createHandlerContext())')
    lines.push('    }')
    lines.push('  }')
    lines.push('')
  }

  // WebSocket handlers
  if (entry.hasWebSocket) {
    if (includeComments) {
      lines.push('  // WebSocket handlers')
    }
    lines.push('  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): Promise<void> {')
    lines.push('    await this.ensureInit()')
    lines.push('    if (definition.config.webSocketMessage) {')
    lines.push('      await definition.config.webSocketMessage.call(this.createHandlerContext(), ws, message)')
    lines.push('    }')
    lines.push('  }')
    lines.push('')

    lines.push('  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean): Promise<void> {')
    lines.push('    await this.ensureInit()')
    lines.push('    if (definition.config.webSocketClose) {')
    lines.push('      await definition.config.webSocketClose.call(this.createHandlerContext(), ws, code, reason)')
    lines.push('    }')
    lines.push('  }')
    lines.push('')

    lines.push('  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {')
    lines.push('    await this.ensureInit()')
    lines.push('    if (definition.config.webSocketError) {')
    lines.push('      await definition.config.webSocketError.call(this.createHandlerContext(), ws, error as Error)')
    lines.push('    }')
    lines.push('  }')
  }

  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Generate an index file that exports all DO classes.
 */
export function generateDOIndexCode(
  entries: DurableObjectEntry[],
  includeComments: boolean = true
): string {
  const lines: string[] = []

  if (includeComments) {
    lines.push('/**')
    lines.push(' * Auto-generated Durable Object class exports')
    lines.push(' * ')
    lines.push(' * DO NOT EDIT - This file is generated by Cloudwerk.')
    lines.push(' */')
    lines.push('')
  }

  for (const entry of entries) {
    lines.push(`export { ${entry.className} } from './${entry.className}.js'`)
  }
  lines.push('')

  return lines.join('\n')
}

// ============================================================================
// File Operations
// ============================================================================

/**
 * Generate all Durable Object class files.
 */
export async function generateDurableObjectClasses(
  cwd: string,
  manifest: DurableObjectManifest,
  options: GenerateDOClassOptions = {}
): Promise<GenerateDOClassResult> {
  const {
    outputDir = '.cloudwerk/generated/objects',
    includeComments = true,
    dryRun = false,
  } = options

  const absoluteOutputDir = path.resolve(cwd, outputDir)
  const result: GenerateDOClassResult = {
    generated: [],
    errors: [],
    outputDir: absoluteOutputDir,
  }

  if (manifest.durableObjects.length === 0) {
    return result
  }

  // Create output directory if needed
  if (!dryRun && !fs.existsSync(absoluteOutputDir)) {
    fs.mkdirSync(absoluteOutputDir, { recursive: true })
  }

  // Generate class files
  for (const entry of manifest.durableObjects) {
    try {
      const code = generateDOClassCode(entry, includeComments)
      const outputPath = path.resolve(cwd, entry.generatedPath)

      if (!dryRun) {
        const dir = path.dirname(outputPath)
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true })
        }
        fs.writeFileSync(outputPath, code, 'utf-8')
      }

      result.generated.push({
        name: entry.name,
        className: entry.className,
        path: outputPath,
      })
    } catch (error) {
      result.errors.push(
        `Failed to generate ${entry.className}: ${error instanceof Error ? error.message : String(error)}`
      )
    }
  }

  // Generate index file
  if (manifest.durableObjects.length > 0 && !dryRun) {
    const indexPath = path.join(absoluteOutputDir, 'index.ts')
    const indexCode = generateDOIndexCode(manifest.durableObjects, includeComments)
    fs.writeFileSync(indexPath, indexCode, 'utf-8')
  }

  return result
}

/**
 * Remove generated Durable Object class files.
 */
export function removeDurableObjectClasses(
  cwd: string,
  outputDir: string = '.cloudwerk/generated/objects'
): boolean {
  const absoluteOutputDir = path.resolve(cwd, outputDir)

  if (!fs.existsSync(absoluteOutputDir)) {
    return false
  }

  try {
    fs.rmSync(absoluteOutputDir, { recursive: true, force: true })
    return true
  } catch {
    return false
  }
}
