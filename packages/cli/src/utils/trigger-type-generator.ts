/**
 * @cloudwerk/cli - Trigger Type Generator
 *
 * Generates TypeScript type declarations for triggers
 * based on discovered trigger definitions in app/triggers/.
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import type { TriggerEntry, TriggerManifest } from '@cloudwerk/core/build'

// ============================================================================
// Constants
// ============================================================================

const CLOUDWERK_TYPES_DIR = '.cloudwerk/types'
const TRIGGERS_DTS = 'triggers.d.ts'

// ============================================================================
// Types
// ============================================================================

export interface GenerateTriggerTypesOptions {
  /** Include timestamp in generated files */
  includeTimestamp?: boolean
}

export interface GenerateTriggerTypesResult {
  /** Path to the generated types directory */
  typesDir: string
  /** Path to generated file */
  file: string
  /** Number of triggers included */
  triggerCount: number
  /** List of triggers with their names */
  triggers: Array<{
    name: string
    bindingName: string
    sourceType: string
  }>
}

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Generate .cloudwerk/types/triggers.d.ts from trigger manifest.
 *
 * Creates module declarations for:
 * - Trigger definitions with proper event types
 * - emit() function type-safe target names
 */
export function generateTriggerTypes(
  cwd: string,
  manifest: TriggerManifest,
  options: GenerateTriggerTypesOptions = {}
): GenerateTriggerTypesResult {
  const includeTimestamp = options.includeTimestamp ?? true
  const typesDir = path.join(cwd, CLOUDWERK_TYPES_DIR)

  // Ensure directory exists
  fs.mkdirSync(typesDir, { recursive: true })

  // Generate triggers.d.ts
  const triggersPath = path.join(typesDir, TRIGGERS_DTS)
  const triggersContent = generateTriggersDts(manifest.triggers, includeTimestamp)
  fs.writeFileSync(triggersPath, triggersContent, 'utf-8')

  // Collect trigger info for result
  const triggerInfo = manifest.triggers.map((t) => ({
    name: t.name,
    bindingName: t.bindingName,
    sourceType: t.source?.type ?? 'unknown',
  }))

  return {
    typesDir,
    file: triggersPath,
    triggerCount: manifest.triggers.length,
    triggers: triggerInfo,
  }
}

/**
 * Generate triggers.d.ts content.
 */
function generateTriggersDts(
  triggers: TriggerEntry[],
  includeTimestamp: boolean
): string {
  const lines: string[] = []

  // Header
  lines.push('// Auto-generated by cloudwerk triggers - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`// Last updated: ${new Date().toISOString()}`)
  }
  lines.push('//')
  lines.push('// This file provides type information for triggers')
  lines.push('// Add ".cloudwerk/types" to your tsconfig.json include array')
  lines.push('')

  // Import types
  lines.push("import type { EmitOptions, EmitResult } from '@cloudwerk/trigger'")
  lines.push('')

  // Group triggers by source type
  const scheduled = triggers.filter((t) => t.source?.type === 'scheduled')
  const queue = triggers.filter((t) => t.source?.type === 'queue')
  const r2 = triggers.filter((t) => t.source?.type === 'r2')
  const webhook = triggers.filter((t) => t.source?.type === 'webhook')
  const email = triggers.filter((t) => t.source?.type === 'email')

  // Generate trigger names union
  lines.push('// ============================================================================')
  lines.push('// Trigger Names')
  lines.push('// ============================================================================')
  lines.push('')

  const allNames = triggers.map((t) => `'${t.name}'`)
  if (allNames.length > 0) {
    lines.push(`type TriggerName = ${allNames.join(' | ')}`)
  } else {
    lines.push('type TriggerName = never')
  }
  lines.push('')

  // Generate category-specific types
  if (scheduled.length > 0) {
    const names = scheduled.map((t) => `'${t.name}'`)
    lines.push(`type ScheduledTriggerName = ${names.join(' | ')}`)
  }
  if (queue.length > 0) {
    const names = queue.map((t) => `'${t.name}'`)
    lines.push(`type QueueTriggerName = ${names.join(' | ')}`)
  }
  if (r2.length > 0) {
    const names = r2.map((t) => `'${t.name}'`)
    lines.push(`type R2TriggerName = ${names.join(' | ')}`)
  }
  if (webhook.length > 0) {
    const names = webhook.map((t) => `'${t.name}'`)
    lines.push(`type WebhookTriggerName = ${names.join(' | ')}`)
  }
  if (email.length > 0) {
    const names = email.map((t) => `'${t.name}'`)
    lines.push(`type EmailTriggerName = ${names.join(' | ')}`)
  }
  lines.push('')

  // Generate trigger info interface
  lines.push('// ============================================================================')
  lines.push('// Trigger Registry')
  lines.push('// ============================================================================')
  lines.push('')
  lines.push('interface TriggerRegistry {')

  for (const trigger of triggers) {
    const sourceType = trigger.source?.type ?? 'unknown'
    lines.push(`  /** ${sourceType} trigger: ${trigger.name} */`)
    lines.push(`  '${trigger.name}': {`)
    lines.push(`    name: '${trigger.name}'`)
    lines.push(`    bindingName: '${trigger.bindingName}'`)
    lines.push(`    sourceType: '${sourceType}'`)
    lines.push('  }')
  }

  lines.push('}')
  lines.push('')

  // Module augmentation for @cloudwerk/trigger
  lines.push('// ============================================================================')
  lines.push('// Module Augmentation')
  lines.push('// ============================================================================')
  lines.push('')
  lines.push("declare module '@cloudwerk/trigger' {")
  lines.push('  /**')
  lines.push('   * Type-safe emit to other triggers.')
  lines.push('   * Only triggers defined in app/triggers/ are valid targets.')
  lines.push('   */')
  lines.push('  export function emit<T extends TriggerName>(')
  lines.push('    trigger: T,')
  lines.push('    payload: unknown,')
  lines.push('    options?: EmitOptions')
  lines.push('  ): Promise<EmitResult>')
  lines.push('')
  lines.push('  /** Get list of all trigger names */')
  lines.push('  export function getTriggerNames(): TriggerName[]')
  lines.push('')
  lines.push('  /** Check if a trigger exists */')
  lines.push('  export function triggerExists(name: string): name is TriggerName')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if .cloudwerk/types/triggers.d.ts exists.
 */
export function triggerTypesExist(cwd: string): boolean {
  const typesPath = path.join(cwd, CLOUDWERK_TYPES_DIR, TRIGGERS_DTS)
  return fs.existsSync(typesPath)
}

/**
 * Delete .cloudwerk/types/triggers.d.ts if it exists.
 */
export function deleteTriggerTypes(cwd: string): boolean {
  const typesPath = path.join(cwd, CLOUDWERK_TYPES_DIR, TRIGGERS_DTS)
  if (fs.existsSync(typesPath)) {
    fs.unlinkSync(typesPath)
    return true
  }
  return false
}

/**
 * Get path to .cloudwerk/types/triggers.d.ts.
 */
export function getTriggerTypesPath(cwd: string): string {
  return path.join(cwd, CLOUDWERK_TYPES_DIR, TRIGGERS_DTS)
}
