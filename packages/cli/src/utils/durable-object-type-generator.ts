/**
 * @cloudwerk/cli - Durable Object Type Generator
 *
 * Generates TypeScript type declarations for durable objects
 * based on discovered definitions in app/objects/.
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import type { DurableObjectEntry, DurableObjectManifest } from '@cloudwerk/core/build'

// ============================================================================
// Constants
// ============================================================================

const CLOUDWERK_TYPES_DIR = '.cloudwerk/types'
const DURABLE_OBJECTS_DTS = 'durable-objects.d.ts'

// ============================================================================
// Types
// ============================================================================

export interface GenerateDurableObjectTypesOptions {
  /** Include timestamp in generated files */
  includeTimestamp?: boolean
}

export interface GenerateDurableObjectTypesResult {
  /** Path to the generated types directory */
  typesDir: string
  /** Path to generated file */
  file: string
  /** Number of durable objects included */
  objectCount: number
  /** List of durable objects with their names */
  durableObjects: Array<{ name: string; bindingName: string; className: string }>
}

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Generate .cloudwerk/types/durable-objects.d.ts from durable object manifest.
 *
 * Creates module declarations for:
 * - @cloudwerk/core/bindings durableObjects proxy with typed namespaces
 */
export function generateDurableObjectTypes(
  cwd: string,
  manifest: DurableObjectManifest,
  options: GenerateDurableObjectTypesOptions = {}
): GenerateDurableObjectTypesResult {
  const includeTimestamp = options.includeTimestamp ?? true
  const typesDir = path.join(cwd, CLOUDWERK_TYPES_DIR)

  // Ensure directory exists
  fs.mkdirSync(typesDir, { recursive: true })

  // Generate durable-objects.d.ts
  const dtsPath = path.join(typesDir, DURABLE_OBJECTS_DTS)
  const dtsContent = generateDurableObjectsDts(manifest.durableObjects, includeTimestamp)
  fs.writeFileSync(dtsPath, dtsContent, 'utf-8')

  // Collect durable object info for result
  const objectInfo = manifest.durableObjects.map((obj) => ({
    name: obj.name,
    bindingName: obj.bindingName,
    className: obj.className,
  }))

  return {
    typesDir,
    file: dtsPath,
    objectCount: manifest.durableObjects.length,
    durableObjects: objectInfo,
  }
}

/**
 * Generate durable-objects.d.ts content.
 */
function generateDurableObjectsDts(
  durableObjects: DurableObjectEntry[],
  includeTimestamp: boolean
): string {
  const lines: string[] = []

  // Header
  lines.push('// Auto-generated by cloudwerk objects - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`// Last updated: ${new Date().toISOString()}`)
  }
  lines.push('//')
  lines.push('// This file provides type information for durable object namespaces')
  lines.push('// Add ".cloudwerk/types" to your tsconfig.json include array')
  lines.push('')

  // Import types
  lines.push("import type { DurableObjectNamespace, DurableObjectStub } from '@cloudwerk/core/bindings'")
  lines.push('')

  // Generate stub interfaces for each durable object
  lines.push('// ============================================================================')
  lines.push('// Durable Object Stub Interfaces')
  lines.push('// ============================================================================')
  lines.push('//')
  lines.push('// Define method signatures for your durable objects.')
  lines.push('// The RPC methods from your defineDurableObject() will be available on stubs.')
  lines.push('//')
  lines.push('')

  for (const obj of durableObjects) {
    lines.push(`/** Stub interface for the '${obj.name}' durable object */`)
    lines.push(`interface ${obj.className}Stub extends DurableObjectStub {`)

    if (obj.methodNames.length > 0) {
      lines.push('  // RPC methods defined in app/objects/' + obj.filePath)
      for (const methodName of obj.methodNames) {
        lines.push(`  ${methodName}(...args: unknown[]): Promise<unknown>`)
      }
    } else {
      lines.push('  // No RPC methods defined - add methods to defineDurableObject({ methods: { ... } })')
    }

    lines.push('}')
    lines.push('')
  }

  // Generate typed namespace interface
  lines.push('// ============================================================================')
  lines.push('// Durable Object Namespace Interfaces')
  lines.push('// ============================================================================')
  lines.push('')

  for (const obj of durableObjects) {
    lines.push(`/** Namespace for the '${obj.name}' durable object (binding: ${obj.bindingName}) */`)
    lines.push(`interface ${obj.className}Namespace extends DurableObjectNamespace<${obj.className}Stub> {`)
    lines.push(`  get(id: import('@cloudwerk/core/bindings').DurableObjectId): ${obj.className}Stub`)
    lines.push('}')
    lines.push('')
  }

  // Generate CloudwerkDurableObjects interface
  lines.push('// ============================================================================')
  lines.push('// Combined Durable Objects Interface')
  lines.push('// ============================================================================')
  lines.push('')
  lines.push('interface CloudwerkDurableObjects {')

  for (const obj of durableObjects) {
    lines.push(`  /** Durable object namespace for '${obj.name}' (binding: ${obj.bindingName}) */`)
    lines.push(`  ${obj.className}: ${obj.className}Namespace`)
  }

  lines.push('}')
  lines.push('')

  // Module declaration for @cloudwerk/core/bindings
  lines.push('// ============================================================================')
  lines.push('// Module Augmentation')
  lines.push('// ============================================================================')
  lines.push('')
  lines.push("declare module '@cloudwerk/core/bindings' {")
  lines.push('  /** Typed durable object namespaces based on app/objects/ definitions */')
  lines.push('  export const durableObjects: CloudwerkDurableObjects')
  lines.push('')
  lines.push('  /** Get a typed durable object namespace by name */')
  lines.push('  export function getDurableObject<K extends keyof CloudwerkDurableObjects>(')
  lines.push('    name: K')
  lines.push('  ): CloudwerkDurableObjects[K]')
  lines.push('}')
  lines.push('')

  // Add to Env type for wrangler
  lines.push('// ============================================================================')
  lines.push('// Env Type Extension')
  lines.push('// ============================================================================')
  lines.push('//')
  lines.push('// Extend your Env type with these bindings:')
  lines.push('//')
  lines.push('// interface Env {')
  for (const obj of durableObjects) {
    lines.push(`//   ${obj.bindingName}: DurableObjectNamespace<${obj.className}Stub>`)
  }
  lines.push('// }')
  lines.push('')

  return lines.join('\n')
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if .cloudwerk/types/durable-objects.d.ts exists.
 */
export function durableObjectTypesExist(cwd: string): boolean {
  const typesPath = path.join(cwd, CLOUDWERK_TYPES_DIR, DURABLE_OBJECTS_DTS)
  return fs.existsSync(typesPath)
}

/**
 * Delete .cloudwerk/types/durable-objects.d.ts if it exists.
 */
export function deleteDurableObjectTypes(cwd: string): boolean {
  const typesPath = path.join(cwd, CLOUDWERK_TYPES_DIR, DURABLE_OBJECTS_DTS)
  if (fs.existsSync(typesPath)) {
    fs.unlinkSync(typesPath)
    return true
  }
  return false
}

/**
 * Get path to .cloudwerk/types/durable-objects.d.ts.
 */
export function getDurableObjectTypesPath(cwd: string): string {
  return path.join(cwd, CLOUDWERK_TYPES_DIR, DURABLE_OBJECTS_DTS)
}
