/**
 * @cloudwerk/cli - Environment Types Generator
 *
 * Generates TypeScript type definitions for Cloudflare bindings.
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import type { Binding, BindingType } from './wrangler-toml.js'

// ============================================================================
// Type Mappings
// ============================================================================

/**
 * Map binding types to TypeScript types.
 */
const TYPE_MAPPINGS: Record<BindingType, string> = {
  d1: 'D1Database',
  kv: 'KVNamespace',
  r2: 'R2Bucket',
  queue: 'Queue',
  do: 'DurableObjectNamespace',
  service: 'Fetcher',
  secret: 'string',
  ai: 'Ai',
  vectorize: 'VectorizeIndex',
  hyperdrive: 'Hyperdrive',
}

/**
 * Get the TypeScript type for a binding.
 */
export function getTypeForBinding(type: BindingType): string {
  return TYPE_MAPPINGS[type] || 'unknown'
}

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Options for generating env.d.ts.
 */
export interface GenerateEnvTypesOptions {
  /** Output file path (default: env.d.ts in cwd) */
  outputPath?: string
  /** Include timestamp in header */
  includeTimestamp?: boolean
}

/**
 * Result of type generation.
 */
export interface GenerateEnvTypesResult {
  /** Path to the generated file */
  outputPath: string
  /** Number of bindings included */
  bindingCount: number
  /** List of binding names and types */
  bindings: Array<{ name: string; type: string }>
}

/**
 * Generate env.d.ts file from bindings.
 */
export function generateEnvTypes(
  cwd: string,
  bindings: Binding[],
  options: GenerateEnvTypesOptions = {}
): GenerateEnvTypesResult {
  const outputPath = options.outputPath || path.join(cwd, 'env.d.ts')
  const includeTimestamp = options.includeTimestamp ?? true

  // Group bindings by type for organized output
  const bindingsByType = new Map<BindingType, Binding[]>()
  for (const binding of bindings) {
    const existing = bindingsByType.get(binding.type) || []
    existing.push(binding)
    bindingsByType.set(binding.type, existing)
  }

  // Build the type definitions
  const lines: string[] = []

  // Header
  lines.push('// Auto-generated by cloudwerk bindings - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`// Last updated: ${new Date().toISOString()}`)
  }
  lines.push('')

  // Start interface
  lines.push('interface CloudflareBindings {')

  // Type order for consistent output
  const typeOrder: BindingType[] = [
    'd1',
    'kv',
    'r2',
    'queue',
    'do',
    'service',
    'ai',
    'vectorize',
    'hyperdrive',
    'secret',
  ]

  const resultBindings: Array<{ name: string; type: string }> = []
  let firstSection = true

  for (const type of typeOrder) {
    const typeBindings = bindingsByType.get(type)
    if (!typeBindings || typeBindings.length === 0) continue

    const tsType = getTypeForBinding(type)
    const sectionName = getSectionName(type)

    // Add section comment
    if (!firstSection) {
      lines.push('')
    }
    lines.push(`  // ${sectionName}`)
    firstSection = false

    // Add each binding
    for (const binding of typeBindings) {
      lines.push(`  ${binding.name}: ${tsType}`)
      resultBindings.push({ name: binding.name, type: tsType })
    }
  }

  // Close interface
  lines.push('}')
  lines.push('')

  // Re-export for convenience
  lines.push('// Re-export for convenience')
  lines.push('type Env = CloudflareBindings')
  lines.push('export type { Env, CloudflareBindings }')
  lines.push('')

  // Write file
  fs.writeFileSync(outputPath, lines.join('\n'), 'utf-8')

  return {
    outputPath,
    bindingCount: bindings.length,
    bindings: resultBindings,
  }
}

/**
 * Get section name for a binding type.
 */
function getSectionName(type: BindingType): string {
  switch (type) {
    case 'd1':
      return 'D1 Databases'
    case 'kv':
      return 'KV Namespaces'
    case 'r2':
      return 'R2 Buckets'
    case 'queue':
      return 'Queues'
    case 'do':
      return 'Durable Objects'
    case 'service':
      return 'Services'
    case 'secret':
      return 'Environment Variables'
    case 'ai':
      return 'AI'
    case 'vectorize':
      return 'Vectorize Indexes'
    case 'hyperdrive':
      return 'Hyperdrive'
    default:
      return 'Other'
  }
}

/**
 * Check if env.d.ts exists.
 */
export function envTypesExist(cwd: string): boolean {
  return fs.existsSync(path.join(cwd, 'env.d.ts'))
}

/**
 * Delete env.d.ts if it exists.
 */
export function deleteEnvTypes(cwd: string): boolean {
  const envPath = path.join(cwd, 'env.d.ts')
  if (fs.existsSync(envPath)) {
    fs.unlinkSync(envPath)
    return true
  }
  return false
}
