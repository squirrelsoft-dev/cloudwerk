/**
 * @cloudwerk/cli - Service Type Generator
 *
 * Generates TypeScript type declarations for services
 * based on discovered service definitions in app/services/.
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import type { ServiceEntry, ServiceManifest } from '@cloudwerk/core/build'

// ============================================================================
// Constants
// ============================================================================

const CLOUDWERK_TYPES_DIR = '.cloudwerk/types'
const SERVICES_DTS = 'services.d.ts'

// ============================================================================
// Types
// ============================================================================

export interface GenerateServiceTypesOptions {
  /** Include timestamp in generated files */
  includeTimestamp?: boolean
}

export interface GenerateServiceTypesResult {
  /** Path to the generated types directory */
  typesDir: string
  /** Path to generated file */
  file: string
  /** Number of services included */
  serviceCount: number
  /** List of services with their names */
  services: Array<{ name: string; bindingName: string; mode: string }>
}

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Generate .cloudwerk/types/services.d.ts from service manifest.
 *
 * Creates module declarations for:
 * - @cloudwerk/core/bindings services proxy with typed services
 * - @cloudwerk/service re-exports
 */
export function generateServiceTypes(
  cwd: string,
  manifest: ServiceManifest,
  options: GenerateServiceTypesOptions = {}
): GenerateServiceTypesResult {
  const includeTimestamp = options.includeTimestamp ?? true
  const typesDir = path.join(cwd, CLOUDWERK_TYPES_DIR)

  // Ensure directory exists
  fs.mkdirSync(typesDir, { recursive: true })

  // Generate services.d.ts
  const servicesPath = path.join(typesDir, SERVICES_DTS)
  const servicesContent = generateServicesDts(manifest.services, includeTimestamp)
  fs.writeFileSync(servicesPath, servicesContent, 'utf-8')

  // Collect service info for result
  const serviceInfo = manifest.services.map((s) => ({
    name: s.name,
    bindingName: s.bindingName,
    mode: s.mode,
  }))

  return {
    typesDir,
    file: servicesPath,
    serviceCount: manifest.services.length,
    services: serviceInfo,
  }
}

/**
 * Generate services.d.ts content.
 */
function generateServicesDts(
  services: ServiceEntry[],
  includeTimestamp: boolean
): string {
  const lines: string[] = []

  // Header
  lines.push('// Auto-generated by cloudwerk services - DO NOT EDIT')
  if (includeTimestamp) {
    lines.push(`// Last updated: ${new Date().toISOString()}`)
  }
  lines.push('//')
  lines.push('// This file provides type information for service interfaces')
  lines.push('// Add ".cloudwerk/types" to your tsconfig.json include array')
  lines.push('')

  // Generate service interface placeholders
  lines.push('// ============================================================================')
  lines.push('// Service Interfaces')
  lines.push('// ============================================================================')
  lines.push('//')
  lines.push('// Define your service interfaces below or in separate type files.')
  lines.push('// These interfaces should match the methods defined in your service.ts files.')
  lines.push('//')
  lines.push('// Example:')
  lines.push('//   interface EmailServiceMethods {')
  lines.push('//     send(params: { to: string; subject: string; body: string }): Promise<{ success: boolean }>')
  lines.push('//     sendBatch(emails: Array<{ to: string; subject: string }>): Promise<{ sent: number }>')
  lines.push('//   }')
  lines.push('//')
  lines.push('')

  for (const service of services) {
    const interfaceName = `${capitalizeFirst(service.name)}ServiceMethods`
    const modeComment = service.mode === 'extracted' ? ' (extracted)' : ' (local)'

    lines.push(`/** Methods for the '${service.name}' service${modeComment} */`)
    lines.push(`// eslint-disable-next-line @typescript-eslint/no-empty-interface`)
    lines.push(`interface ${interfaceName} {`)

    // Add method signatures if we have method names
    if (service.methodNames.length > 0) {
      for (const methodName of service.methodNames) {
        lines.push(`  /** Method: ${methodName} */`)
        lines.push(`  ${methodName}(...args: unknown[]): Promise<unknown>`)
      }
    } else {
      lines.push('  // Add method signatures here')
    }

    lines.push('}')
    lines.push('')
  }

  // Generate services interface
  lines.push('// ============================================================================')
  lines.push('// Services Interface')
  lines.push('// ============================================================================')
  lines.push('')
  lines.push('interface CloudwerkServices {')

  for (const service of services) {
    const interfaceName = `${capitalizeFirst(service.name)}ServiceMethods`
    const modeComment = service.mode === 'extracted'
      ? `extracted (binding: ${service.bindingName})`
      : 'local (direct calls)'
    lines.push(`  /** Service '${service.name}' - ${modeComment} */`)
    lines.push(`  ${service.name}: ${interfaceName}`)
  }

  lines.push('}')
  lines.push('')

  // Module declaration for @cloudwerk/core/bindings
  lines.push('// ============================================================================')
  lines.push('// Module Augmentation')
  lines.push('// ============================================================================')
  lines.push('')
  lines.push("declare module '@cloudwerk/core/bindings' {")
  lines.push('  /** Typed services based on app/services/ definitions */')
  lines.push('  export const services: CloudwerkServices')
  lines.push('')
  lines.push('  /** Get a typed service by name */')
  lines.push('  export function getService<K extends keyof CloudwerkServices>(')
  lines.push('    name: K')
  lines.push('  ): CloudwerkServices[K]')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

/**
 * Capitalize the first letter of a string.
 */
function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if .cloudwerk/types/services.d.ts exists.
 */
export function serviceTypesExist(cwd: string): boolean {
  const typesPath = path.join(cwd, CLOUDWERK_TYPES_DIR, SERVICES_DTS)
  return fs.existsSync(typesPath)
}

/**
 * Delete .cloudwerk/types/services.d.ts if it exists.
 */
export function deleteServiceTypes(cwd: string): boolean {
  const typesPath = path.join(cwd, CLOUDWERK_TYPES_DIR, SERVICES_DTS)
  if (fs.existsSync(typesPath)) {
    fs.unlinkSync(typesPath)
    return true
  }
  return false
}

/**
 * Get path to .cloudwerk/types/services.d.ts.
 */
export function getServiceTypesPath(cwd: string): string {
  return path.join(cwd, CLOUDWERK_TYPES_DIR, SERVICES_DTS)
}
