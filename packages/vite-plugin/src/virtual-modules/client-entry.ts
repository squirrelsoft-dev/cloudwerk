/**
 * Client Entry Virtual Module Generator
 *
 * Generates the virtual:cloudwerk/client-entry module that handles
 * client-side hydration of server-rendered components.
 */

import type { ResolvedCloudwerkOptions, ClientComponentInfo } from '../types.js'

/**
 * Generate the client entry module code.
 *
 * This creates a hydration bootstrap that:
 * - Finds all elements with data-hydrate-id attributes
 * - Dynamically imports the corresponding component bundles
 * - Hydrates each component with its serialized props
 *
 * @param clientComponents - Map of detected client components
 * @param options - Resolved plugin options
 * @returns Generated JavaScript code
 */
export function generateClientEntry(
  clientComponents: Map<string, ClientComponentInfo>,
  options: ResolvedCloudwerkOptions
): string {
  const { renderer, hydrationEndpoint } = options

  if (renderer === 'react') {
    return generateReactClientEntry(clientComponents, hydrationEndpoint)
  }

  return generateHonoClientEntry(clientComponents, hydrationEndpoint)
}

/**
 * Generate Hono JSX client entry.
 */
function generateHonoClientEntry(
  clientComponents: Map<string, ClientComponentInfo>,
  _hydrationEndpoint: string
): string {
  // Use /@fs/ prefix for Vite to serve absolute file paths in dev mode
  const bundleMap = Object.fromEntries(
    Array.from(clientComponents.values()).map((info) => [info.componentId, `/@fs${info.absolutePath}`])
  )

  return `/**
 * Generated Cloudwerk Client Entry (Hono JSX)
 * This file is auto-generated by @cloudwerk/vite-plugin - do not edit
 */

import { render } from 'hono/jsx/dom'
import { jsx } from 'hono/jsx/jsx-runtime'

// Bundle map for component lookups
const bundles = ${JSON.stringify(bundleMap, null, 2)}

// Module cache to avoid re-importing
const moduleCache = new Map()

/**
 * Load a component module, using cache for repeated imports.
 */
async function loadComponent(bundlePath) {
  if (moduleCache.has(bundlePath)) {
    return moduleCache.get(bundlePath)
  }
  const module = await import(/* @vite-ignore */ bundlePath)
  moduleCache.set(bundlePath, module)
  return module
}

/**
 * Hydrate all marked elements on the page.
 */
async function hydrate() {
  const elements = document.querySelectorAll('[data-hydrate-id]')
  if (elements.length === 0) {
    console.debug('[Cloudwerk] No client components to hydrate')
    return
  }

  console.debug('[Cloudwerk] Hydrating', elements.length, 'client components')

  for (const el of elements) {
    const componentId = el.getAttribute('data-hydrate-id')
    const propsJson = el.getAttribute('data-hydrate-props')

    if (!componentId) {
      console.warn('[Cloudwerk] Element missing data-hydrate-id')
      continue
    }

    const bundlePath = bundles[componentId]
    if (!bundlePath) {
      console.warn('[Cloudwerk] Unknown client component:', componentId)
      continue
    }

    try {
      const props = propsJson ? JSON.parse(propsJson) : {}
      const module = await loadComponent(bundlePath)
      const Component = module.default

      if (!Component) {
        console.error('[Cloudwerk] No default export in component:', componentId)
        continue
      }

      // Hydrate the component using jsx() to create a proper element
      // This allows Hono's reactive system to manage re-renders
      render(jsx(Component, props), el)

      // Clean up hydration attributes
      el.removeAttribute('data-hydrate-id')
      el.removeAttribute('data-hydrate-props')

      console.debug('[Cloudwerk] Hydrated:', componentId)
    } catch (error) {
      console.error('[Cloudwerk] Failed to hydrate component:', componentId, error)
    }
  }
}

// Run hydration when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hydrate)
} else {
  hydrate()
}

// Export for manual hydration if needed
export { hydrate }
`
}

/**
 * Generate React client entry.
 */
function generateReactClientEntry(
  clientComponents: Map<string, ClientComponentInfo>,
  _hydrationEndpoint: string
): string {
  // Use /@fs/ prefix for Vite to serve absolute file paths in dev mode
  const bundleMap = Object.fromEntries(
    Array.from(clientComponents.values()).map((info) => [info.componentId, `/@fs${info.absolutePath}`])
  )

  return `/**
 * Generated Cloudwerk Client Entry (React)
 * This file is auto-generated by @cloudwerk/vite-plugin - do not edit
 */

import { hydrateRoot, createRoot } from 'react-dom/client'
import { createElement } from 'react'

// Bundle map for component lookups
const bundles = ${JSON.stringify(bundleMap, null, 2)}

// Module cache to avoid re-importing
const moduleCache = new Map()

// Root cache for React 18 concurrent mode
const rootCache = new Map()

/**
 * Load a component module, using cache for repeated imports.
 */
async function loadComponent(bundlePath) {
  if (moduleCache.has(bundlePath)) {
    return moduleCache.get(bundlePath)
  }
  const module = await import(/* @vite-ignore */ bundlePath)
  moduleCache.set(bundlePath, module)
  return module
}

/**
 * Hydrate all marked elements on the page.
 */
async function hydrate() {
  const elements = document.querySelectorAll('[data-hydrate-id]')
  if (elements.length === 0) {
    console.debug('[Cloudwerk] No client components to hydrate')
    return
  }

  console.debug('[Cloudwerk] Hydrating', elements.length, 'client components')

  for (const el of elements) {
    const componentId = el.getAttribute('data-hydrate-id')
    const propsJson = el.getAttribute('data-hydrate-props')

    if (!componentId) {
      console.warn('[Cloudwerk] Element missing data-hydrate-id')
      continue
    }

    const bundlePath = bundles[componentId]
    if (!bundlePath) {
      console.warn('[Cloudwerk] Unknown client component:', componentId)
      continue
    }

    try {
      const props = propsJson ? JSON.parse(propsJson) : {}
      const module = await loadComponent(bundlePath)
      const Component = module.default

      if (!Component) {
        console.error('[Cloudwerk] No default export in component:', componentId)
        continue
      }

      // Hydrate the component using React 18 hydrateRoot
      const root = hydrateRoot(el, createElement(Component, props))
      rootCache.set(el, root)

      // Clean up hydration attributes
      el.removeAttribute('data-hydrate-id')
      el.removeAttribute('data-hydrate-props')

      console.debug('[Cloudwerk] Hydrated:', componentId)
    } catch (error) {
      console.error('[Cloudwerk] Failed to hydrate component:', componentId, error)
    }
  }
}

// Run hydration when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hydrate)
} else {
  hydrate()
}

// Export for manual hydration if needed
export { hydrate }
`
}
