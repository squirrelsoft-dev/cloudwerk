/**
 * Client Entry Virtual Module Generator
 *
 * Generates the virtual:cloudwerk/client-entry module that handles
 * client-side hydration of server-rendered components.
 */

import type { ResolvedCloudwerkOptions, ClientComponentInfo } from '../types.js'

/**
 * Generate the client entry module code.
 *
 * This creates a hydration bootstrap that:
 * - Finds all elements with data-hydrate-id attributes
 * - Dynamically imports the corresponding component bundles
 * - Hydrates each component with its serialized props
 *
 * @param clientComponents - Map of detected client components
 * @param options - Resolved plugin options
 * @returns Generated JavaScript code
 */
export function generateClientEntry(
  clientComponents: Map<string, ClientComponentInfo>,
  options: ResolvedCloudwerkOptions
): string {
  const { renderer, hydrationEndpoint, isProduction } = options

  if (renderer === 'react') {
    return generateReactClientEntry(clientComponents, hydrationEndpoint, isProduction)
  }

  return generateHonoClientEntry(clientComponents, hydrationEndpoint, isProduction)
}

/**
 * Generate Hono JSX client entry.
 */
function generateHonoClientEntry(
  clientComponents: Map<string, ClientComponentInfo>,
  _hydrationEndpoint: string,
  isProduction: boolean = false
): string {
  // In production, generate static imports and a component map
  // In dev, use dynamic imports with /@fs/ prefix for Vite to serve absolute file paths
  if (isProduction) {
    return generateHonoClientEntryProduction(clientComponents)
  }

  const bundleMap = Object.fromEntries(
    Array.from(clientComponents.values()).map((info) => [info.componentId, `/@fs${info.absolutePath}`])
  )

  return `/**
 * Generated Cloudwerk Client Entry (Hono JSX)
 * This file is auto-generated by @cloudwerk/vite-plugin - do not edit
 */

import { render } from 'hono/jsx/dom'
import { jsx } from 'hono/jsx/jsx-runtime'

// Bundle map for component lookups
const bundles = ${JSON.stringify(bundleMap, null, 2)}

// Module cache to avoid re-importing
const moduleCache = new Map()

/**
 * Load a component module, using cache for repeated imports.
 */
async function loadComponent(bundlePath) {
  if (moduleCache.has(bundlePath)) {
    return moduleCache.get(bundlePath)
  }
  const module = await import(/* @vite-ignore */ bundlePath)
  moduleCache.set(bundlePath, module)
  return module
}

/**
 * Hydrate all marked elements on the page.
 */
async function hydrate() {
  const elements = document.querySelectorAll('[data-hydrate-id]')
  if (elements.length === 0) {
    console.debug('[Cloudwerk] No client components to hydrate')
    return
  }

  console.debug('[Cloudwerk] Hydrating', elements.length, 'client components')

  for (const el of elements) {
    const componentId = el.getAttribute('data-hydrate-id')
    const propsJson = el.getAttribute('data-hydrate-props')

    if (!componentId) {
      console.warn('[Cloudwerk] Element missing data-hydrate-id')
      continue
    }

    const bundlePath = bundles[componentId]
    if (!bundlePath) {
      console.warn('[Cloudwerk] Unknown client component:', componentId)
      continue
    }

    try {
      const props = propsJson ? JSON.parse(propsJson) : {}
      const module = await loadComponent(bundlePath)
      const Component = module.default

      if (!Component) {
        console.error('[Cloudwerk] No default export in component:', componentId)
        continue
      }

      // Hydrate the component using jsx() to create a proper element
      // This allows Hono's reactive system to manage re-renders
      render(jsx(Component, props), el)

      // Clean up hydration attributes
      el.removeAttribute('data-hydrate-id')
      el.removeAttribute('data-hydrate-props')

      console.debug('[Cloudwerk] Hydrated:', componentId)
    } catch (error) {
      console.error('[Cloudwerk] Failed to hydrate component:', componentId, error)
    }
  }
}

// Run hydration when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hydrate)
} else {
  hydrate()
}

// Export for manual hydration if needed
export { hydrate }
`
}

/**
 * Generate Hono JSX client entry for production.
 * Uses static imports so components are bundled together.
 */
function generateHonoClientEntryProduction(
  clientComponents: Map<string, ClientComponentInfo>
): string {
  const components = Array.from(clientComponents.values())

  // Generate static imports for each component
  const imports = components.map((info, index) =>
    `import Component${index} from '${info.absolutePath}'`
  ).join('\n')

  // Generate component map
  const componentMapEntries = components.map((info, index) =>
    `  '${info.componentId}': Component${index}`
  ).join(',\n')

  return `/**
 * Generated Cloudwerk Client Entry (Hono JSX - Production)
 * This file is auto-generated by @cloudwerk/vite-plugin - do not edit
 */

import { render } from 'hono/jsx/dom'
import { jsx } from 'hono/jsx/jsx-runtime'

// Static component imports
${imports}

// Component map for hydration lookups
const components = {
${componentMapEntries}
}

/**
 * Hydrate all marked elements on the page.
 */
async function hydrate() {
  const elements = document.querySelectorAll('[data-hydrate-id]')
  if (elements.length === 0) {
    console.debug('[Cloudwerk] No client components to hydrate')
    return
  }

  console.debug('[Cloudwerk] Hydrating', elements.length, 'client components')

  for (const el of elements) {
    const componentId = el.getAttribute('data-hydrate-id')
    const propsJson = el.getAttribute('data-hydrate-props')

    if (!componentId) {
      console.warn('[Cloudwerk] Element missing data-hydrate-id')
      continue
    }

    const Component = components[componentId]
    if (!Component) {
      console.warn('[Cloudwerk] Unknown client component:', componentId)
      continue
    }

    try {
      const props = propsJson ? JSON.parse(propsJson) : {}

      // Hydrate the component using jsx() to create a proper element
      // This allows Hono's reactive system to manage re-renders
      render(jsx(Component, props), el)

      // Clean up hydration attributes
      el.removeAttribute('data-hydrate-id')
      el.removeAttribute('data-hydrate-props')

      console.debug('[Cloudwerk] Hydrated:', componentId)
    } catch (error) {
      console.error('[Cloudwerk] Failed to hydrate component:', componentId, error)
    }
  }
}

// Run hydration when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hydrate)
} else {
  hydrate()
}

// Export for manual hydration if needed
export { hydrate }
`
}

/**
 * Generate React client entry.
 */
function generateReactClientEntry(
  clientComponents: Map<string, ClientComponentInfo>,
  _hydrationEndpoint: string,
  isProduction: boolean = false
): string {
  // In production, generate static imports and a component map
  if (isProduction) {
    return generateReactClientEntryProduction(clientComponents)
  }

  // Use /@fs/ prefix for Vite to serve absolute file paths in dev mode
  const bundleMap = Object.fromEntries(
    Array.from(clientComponents.values()).map((info) => [info.componentId, `/@fs${info.absolutePath}`])
  )

  return `/**
 * Generated Cloudwerk Client Entry (React)
 * This file is auto-generated by @cloudwerk/vite-plugin - do not edit
 */

import { hydrateRoot, createRoot } from 'react-dom/client'
import { createElement } from 'react'

// Bundle map for component lookups
const bundles = ${JSON.stringify(bundleMap, null, 2)}

// Module cache to avoid re-importing
const moduleCache = new Map()

// Root cache for React 18 concurrent mode
const rootCache = new Map()

/**
 * Load a component module, using cache for repeated imports.
 */
async function loadComponent(bundlePath) {
  if (moduleCache.has(bundlePath)) {
    return moduleCache.get(bundlePath)
  }
  const module = await import(/* @vite-ignore */ bundlePath)
  moduleCache.set(bundlePath, module)
  return module
}

/**
 * Hydrate all marked elements on the page.
 */
async function hydrate() {
  const elements = document.querySelectorAll('[data-hydrate-id]')
  if (elements.length === 0) {
    console.debug('[Cloudwerk] No client components to hydrate')
    return
  }

  console.debug('[Cloudwerk] Hydrating', elements.length, 'client components')

  for (const el of elements) {
    const componentId = el.getAttribute('data-hydrate-id')
    const propsJson = el.getAttribute('data-hydrate-props')

    if (!componentId) {
      console.warn('[Cloudwerk] Element missing data-hydrate-id')
      continue
    }

    const bundlePath = bundles[componentId]
    if (!bundlePath) {
      console.warn('[Cloudwerk] Unknown client component:', componentId)
      continue
    }

    try {
      const props = propsJson ? JSON.parse(propsJson) : {}
      const module = await loadComponent(bundlePath)
      const Component = module.default

      if (!Component) {
        console.error('[Cloudwerk] No default export in component:', componentId)
        continue
      }

      // Hydrate the component using React 18 hydrateRoot
      const root = hydrateRoot(el, createElement(Component, props))
      rootCache.set(el, root)

      // Clean up hydration attributes
      el.removeAttribute('data-hydrate-id')
      el.removeAttribute('data-hydrate-props')

      console.debug('[Cloudwerk] Hydrated:', componentId)
    } catch (error) {
      console.error('[Cloudwerk] Failed to hydrate component:', componentId, error)
    }
  }
}

// Run hydration when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hydrate)
} else {
  hydrate()
}

// Export for manual hydration if needed
export { hydrate }
`
}

/**
 * Generate React client entry for production.
 * Uses static imports so components are bundled together.
 */
function generateReactClientEntryProduction(
  clientComponents: Map<string, ClientComponentInfo>
): string {
  const components = Array.from(clientComponents.values())

  // Generate static imports for each component
  const imports = components.map((info, index) =>
    `import Component${index} from '${info.absolutePath}'`
  ).join('\n')

  // Generate component map
  const componentMapEntries = components.map((info, index) =>
    `  '${info.componentId}': Component${index}`
  ).join(',\n')

  return `/**
 * Generated Cloudwerk Client Entry (React - Production)
 * This file is auto-generated by @cloudwerk/vite-plugin - do not edit
 */

import { hydrateRoot } from 'react-dom/client'
import { createElement } from 'react'

// Static component imports
${imports}

// Component map for hydration lookups
const components = {
${componentMapEntries}
}

// Root cache for React 18 concurrent mode
const rootCache = new Map()

/**
 * Hydrate all marked elements on the page.
 */
async function hydrate() {
  const elements = document.querySelectorAll('[data-hydrate-id]')
  if (elements.length === 0) {
    console.debug('[Cloudwerk] No client components to hydrate')
    return
  }

  console.debug('[Cloudwerk] Hydrating', elements.length, 'client components')

  for (const el of elements) {
    const componentId = el.getAttribute('data-hydrate-id')
    const propsJson = el.getAttribute('data-hydrate-props')

    if (!componentId) {
      console.warn('[Cloudwerk] Element missing data-hydrate-id')
      continue
    }

    const Component = components[componentId]
    if (!Component) {
      console.warn('[Cloudwerk] Unknown client component:', componentId)
      continue
    }

    try {
      const props = propsJson ? JSON.parse(propsJson) : {}

      // Hydrate the component using React 18 hydrateRoot
      const root = hydrateRoot(el, createElement(Component, props))
      rootCache.set(el, root)

      // Clean up hydration attributes
      el.removeAttribute('data-hydrate-id')
      el.removeAttribute('data-hydrate-props')

      console.debug('[Cloudwerk] Hydrated:', componentId)
    } catch (error) {
      console.error('[Cloudwerk] Failed to hydrate component:', componentId, error)
    }
  }
}

// Run hydration when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', hydrate)
} else {
  hydrate()
}

// Export for manual hydration if needed
export { hydrate }
`
}
