/**
 * Server Entry Virtual Module Generator
 *
 * Generates the virtual:cloudwerk/server-entry module that creates
 * a Hono app with all routes registered from the file-based routing manifest.
 */

import type { RouteManifest, ScanResult } from '@cloudwerk/core'
import type { ResolvedCloudwerkOptions } from '../types.js'

/**
 * Generate the server entry module code.
 *
 * This creates a complete Hono application with:
 * - All page and API routes registered
 * - Layouts applied to pages in correct order
 * - Middleware chains applied
 * - Route config support
 * - Error and 404 handling
 *
 * @param manifest - Route manifest from @cloudwerk/core
 * @param scanResult - Scan result with file information
 * @param options - Resolved plugin options
 * @returns Generated TypeScript/JavaScript code
 */
export function generateServerEntry(
  manifest: RouteManifest,
  scanResult: ScanResult,
  options: ResolvedCloudwerkOptions
): string {
  const imports: string[] = []
  const pageRegistrations: string[] = []
  const routeRegistrations: string[] = []
  const layoutImports: string[] = []
  const middlewareImports: string[] = []

  // Track imported modules to avoid duplicates
  const importedModules = new Set<string>()
  const layoutModules = new Map<string, string>() // path -> varName
  const middlewareModules = new Map<string, string>() // path -> varName

  let pageIndex = 0
  let routeIndex = 0
  let layoutIndex = 0
  let middlewareIndex = 0

  // Process each route
  for (const route of manifest.routes) {
    // Generate imports for middleware
    for (const middlewarePath of route.middleware) {
      if (!importedModules.has(middlewarePath)) {
        const varName = `middleware_${middlewareIndex++}`
        middlewareImports.push(`import ${varName} from '${middlewarePath}'`)
        middlewareModules.set(middlewarePath, varName)
        importedModules.add(middlewarePath)
      }
    }

    // Generate imports for layouts (pages only)
    if (route.fileType === 'page') {
      for (const layoutPath of route.layouts) {
        if (!importedModules.has(layoutPath)) {
          const varName = `layout_${layoutIndex++}`
          layoutImports.push(`import * as ${varName} from '${layoutPath}'`)
          layoutModules.set(layoutPath, varName)
          importedModules.add(layoutPath)
        }
      }
    }

    if (route.fileType === 'page') {
      // Page route - import page module and register GET handler
      const varName = `page_${pageIndex++}`
      imports.push(`import * as ${varName} from '${route.absolutePath}'`)

      // Generate layout chain for this route
      const layoutChain = route.layouts.map((p) => layoutModules.get(p)!).join(', ')
      const middlewareChain = route.middleware.map((p) => middlewareModules.get(p)!).join(', ')

      pageRegistrations.push(
        `  registerPage(app, '${route.urlPattern}', ${varName}, [${layoutChain}], [${middlewareChain}])`
      )
    } else if (route.fileType === 'route') {
      // API route - import route module and register HTTP handlers
      const varName = `route_${routeIndex++}`
      imports.push(`import * as ${varName} from '${route.absolutePath}'`)

      const middlewareChain = route.middleware.map((p) => middlewareModules.get(p)!).join(', ')

      routeRegistrations.push(
        `  registerRoute(app, '${route.urlPattern}', ${varName}, [${middlewareChain}])`
      )
    }
  }

  const rendererName = options.renderer

  return `/**
 * Generated Cloudwerk Server Entry
 * This file is auto-generated by @cloudwerk/vite-plugin - do not edit
 */

import { Hono } from 'hono'
import type { Context, MiddlewareHandler } from 'hono'
import { contextMiddleware, createHandlerAdapter, setRouteConfig } from '@cloudwerk/core'
import { renderToStream, setActiveRenderer } from '@cloudwerk/ui'
import type { PageProps, LayoutProps, RouteConfig, LoaderArgs, HttpMethod } from '@cloudwerk/core'

// Page and Route Imports
${imports.join('\n')}

// Layout Imports
${layoutImports.join('\n')}

// Middleware Imports
${middlewareImports.join('\n')}

// ============================================================================
// Route Registration Helpers
// ============================================================================

interface PageModule {
  default: (props: PageProps) => unknown
  loader?: (args: LoaderArgs) => unknown
  config?: RouteConfig
}

interface LayoutModule {
  default: (props: LayoutProps) => unknown
  loader?: (args: LoaderArgs) => unknown
}

interface RouteModule {
  GET?: unknown
  POST?: unknown
  PUT?: unknown
  PATCH?: unknown
  DELETE?: unknown
  OPTIONS?: unknown
  HEAD?: unknown
  config?: RouteConfig
}

const HTTP_METHODS: HttpMethod[] = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD']

function registerPage(
  app: Hono,
  pattern: string,
  pageModule: PageModule,
  layoutModules: LayoutModule[],
  middlewareModules: MiddlewareHandler[]
) {
  // Apply middleware
  for (const mw of middlewareModules) {
    app.use(pattern, mw)
  }

  // Apply config middleware if present
  if (pageModule.config) {
    app.use(pattern, async (_c, next) => {
      setRouteConfig(pageModule.config!)
      await next()
    })
  }

  // Register GET handler for page
  app.get(pattern, async (c: Context) => {
    const params = c.req.param()
    const request = c.req.raw
    const url = new URL(request.url)
    const searchParams = Object.fromEntries(url.searchParams.entries())

    // Execute layout loaders
    const layoutLoaderData: Record<string, unknown>[] = []
    const loaderArgs: LoaderArgs = { params, request, context: c }

    for (const layoutModule of layoutModules) {
      if (layoutModule.loader) {
        const data = await Promise.resolve(layoutModule.loader(loaderArgs))
        layoutLoaderData.push((data ?? {}) as Record<string, unknown>)
      } else {
        layoutLoaderData.push({})
      }
    }

    // Execute page loader
    let pageLoaderData: Record<string, unknown> = {}
    if (pageModule.loader) {
      pageLoaderData = (await Promise.resolve(pageModule.loader(loaderArgs))) as Record<string, unknown> ?? {}
    }

    // Build page props
    const pageProps: PageProps = { params, searchParams, ...pageLoaderData }

    // Render page
    let element = await Promise.resolve(pageModule.default(pageProps))

    // Wrap with layouts (inside-out)
    for (let i = layoutModules.length - 1; i >= 0; i--) {
      const Layout = layoutModules[i].default
      const layoutProps: LayoutProps = {
        children: element,
        params,
        ...layoutLoaderData[i],
      }
      element = await Promise.resolve(Layout(layoutProps))
    }

    return renderToStream(element)
  })
}

function registerRoute(
  app: Hono,
  pattern: string,
  routeModule: RouteModule,
  middlewareModules: MiddlewareHandler[]
) {
  // Apply middleware
  for (const mw of middlewareModules) {
    app.use(pattern, mw)
  }

  // Apply config middleware if present
  if (routeModule.config) {
    app.use(pattern, async (_c, next) => {
      setRouteConfig(routeModule.config!)
      await next()
    })
  }

  // Register each HTTP method handler
  for (const method of HTTP_METHODS) {
    const handler = routeModule[method]
    if (handler && typeof handler === 'function') {
      const h = handler.length === 2 ? createHandlerAdapter(handler as any) : handler as any
      switch (method) {
        case 'GET': app.get(pattern, h); break
        case 'POST': app.post(pattern, h); break
        case 'PUT': app.put(pattern, h); break
        case 'PATCH': app.patch(pattern, h); break
        case 'DELETE': app.delete(pattern, h); break
        case 'OPTIONS': app.options(pattern, h); break
        case 'HEAD': app.on('HEAD', [pattern], h); break
      }
    }
  }
}

// ============================================================================
// App Initialization
// ============================================================================

// Initialize renderer
setActiveRenderer('${rendererName}')

// Create Hono app
const app = new Hono({ strict: false })

// Add context middleware
app.use('*', contextMiddleware())

// Register all routes
${pageRegistrations.join('\n')}
${routeRegistrations.join('\n')}

// 404 handler
app.notFound((c) => {
  return c.json({ error: 'Not Found', path: c.req.path }, 404)
})

// Error handler
app.onError((err, c) => {
  console.error('Request error:', err.message)
  return c.json({ error: 'Internal Server Error', message: err.message }, 500)
})

// ============================================================================
// Export
// ============================================================================

export default app
`
}
