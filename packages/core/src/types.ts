/**
 * @cloudwerk/core - Type Definitions
 *
 * Core types for the file-based route compiler.
 */

import type { Context, MiddlewareHandler } from 'hono'

// ============================================================================
// Route Segment Types
// ============================================================================

/**
 * Represents a static route segment (e.g., "about", "users")
 */
export interface StaticSegment {
  type: 'static'
  value: string
}

/**
 * Represents a dynamic route segment (e.g., "[id]" -> ":id")
 */
export interface DynamicSegment {
  type: 'dynamic'
  name: string
}

/**
 * Represents a catch-all route segment (e.g., "[...path]" -> "*path")
 */
export interface CatchAllSegment {
  type: 'catchAll'
  name: string
}

/**
 * Represents an optional catch-all route segment (e.g., "[[...cat]]" -> ":cat*")
 */
export interface OptionalCatchAllSegment {
  type: 'optionalCatchAll'
  name: string
}

/**
 * Union type for all route segment types
 */
export type RouteSegment =
  | StaticSegment
  | DynamicSegment
  | CatchAllSegment
  | OptionalCatchAllSegment

// ============================================================================
// File Type Definitions
// ============================================================================

/**
 * Supported route file types
 */
export type RouteFileType =
  | 'page'      // page.tsx, page.ts - UI routes
  | 'route'     // route.ts - API routes
  | 'layout'    // layout.tsx - Shared layouts
  | 'middleware' // middleware.ts - Route middleware
  | 'loading'   // loading.tsx - Loading states
  | 'error'     // error.tsx - Error boundaries
  | 'not-found' // not-found.tsx - 404 pages

/**
 * File extensions we support
 */
export const SUPPORTED_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx'] as const
export type SupportedExtension = typeof SUPPORTED_EXTENSIONS[number]

/**
 * Route file names we recognize
 */
export const ROUTE_FILE_NAMES = [
  'page',
  'route',
  'layout',
  'middleware',
  'loading',
  'error',
  'not-found',
] as const

// ============================================================================
// Route Entry Types
// ============================================================================

/**
 * HTTP methods supported for route handlers
 */
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'

/**
 * Represents a single route entry in the manifest
 */
export interface RouteEntry {
  /** The URL pattern for Hono (e.g., "/users/:id") */
  urlPattern: string

  /** Original file path relative to routes directory */
  filePath: string

  /** Absolute file path for importing */
  absolutePath: string

  /** Type of route file */
  fileType: RouteFileType

  /** Parsed route segments */
  segments: RouteSegment[]

  /** HTTP methods this route handles (for route.ts files) */
  methods?: HttpMethod[]

  /** Layout files that wrap this route (in order from root to closest) */
  layouts: string[]

  /** Middleware files that apply to this route (in order from root to closest) */
  middleware: string[]

  /** Priority for route sorting (lower = higher priority) */
  priority: number
}

// ============================================================================
// Route Manifest Types
// ============================================================================

/**
 * Validation error for routes
 */
export interface RouteValidationError {
  /** Type of validation error */
  type: 'conflict' | 'invalid-segment' | 'missing-file' | 'invalid-pattern'

  /** Human-readable error message */
  message: string

  /** File path(s) involved in the error */
  files: string[]
}

/**
 * Validation warning for routes (non-blocking)
 */
export interface RouteValidationWarning {
  /** Type of warning */
  type: 'unused-layout' | 'deep-nesting' | 'naming-convention'

  /** Human-readable warning message */
  message: string

  /** File path(s) involved in the warning */
  files: string[]
}

/**
 * The complete route manifest generated by the compiler
 */
export interface RouteManifest {
  /** All discovered route entries, sorted by priority */
  routes: RouteEntry[]

  /** All layout files discovered */
  layouts: Map<string, string>

  /** All middleware files discovered */
  middleware: Map<string, string>

  /** Validation errors that prevent building */
  errors: RouteValidationError[]

  /** Validation warnings (non-blocking) */
  warnings: RouteValidationWarning[]

  /** Timestamp when manifest was generated */
  generatedAt: Date

  /** Root directory that was scanned */
  rootDir: string
}

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * Configuration options for the route compiler
 */
export interface CloudwerkConfig {
  /** Directory containing route files (default: "app") */
  routesDir: string

  /** File extensions to scan (default: ['.ts', '.tsx']) */
  extensions: SupportedExtension[]

  /** Whether to enable strict validation (default: true) */
  strict: boolean

  /** Custom middleware to apply to all routes */
  globalMiddleware?: MiddlewareHandler[]

  /** Base path for all routes (default: "/") */
  basePath: string

  /** Whether to enable debug logging (default: false) */
  debug: boolean
}

/**
 * Partial config for user-provided options
 */
export type CloudwerkUserConfig = Partial<CloudwerkConfig>

// ============================================================================
// Handler Types
// ============================================================================

/**
 * Page component props
 */
export interface PageProps<TParams = Record<string, string>> {
  params: TParams
  searchParams: Record<string, string | string[] | undefined>
}

/**
 * Layout component props
 */
export interface LayoutProps<TParams = Record<string, string>> {
  children: unknown
  params: TParams
}

/**
 * Route handler context (extends Hono context)
 * @deprecated Use CloudwerkHandlerContext with CloudwerkHandler instead.
 * This type will be removed in a future version.
 */
export type RouteContext<TParams = Record<string, string>> = Context & {
  req: {
    param: () => TParams
  }
}

/**
 * Route handler function signature
 * @deprecated Use CloudwerkHandler instead, which provides a cleaner signature:
 * `(request: Request, context: CloudwerkHandlerContext) => Response`
 * This type will be removed in a future version.
 */
export type RouteHandler<TParams = Record<string, string>> = (
  c: RouteContext<TParams>
) => Response | Promise<Response>

// ============================================================================
// Cloudwerk Native Handler Types
// ============================================================================

/**
 * Handler context passed directly to route handlers.
 * Use getContext() for full context including env and executionCtx.
 */
export interface CloudwerkHandlerContext<TParams = Record<string, string>> {
  /** Route parameters from dynamic segments */
  params: TParams
}

/**
 * Cloudwerk-native route handler signature.
 *
 * **Important**: Both parameters must be declared for automatic detection.
 * Use `_context` if the context parameter is unused.
 *
 * @example
 * // With params
 * export function GET(request: Request, { params }: CloudwerkHandlerContext<{ id: string }>) {
 *   return json({ userId: params.id })
 * }
 *
 * @example
 * // Without params (still need second parameter for detection)
 * export function GET(request: Request, _context: CloudwerkHandlerContext) {
 *   return new Response('Hello Cloudwerk')
 * }
 *
 * @example
 * // Accessing env and request together
 * export function GET(request: Request, context: CloudwerkHandlerContext<{ id: string }>) {
 *   const { id } = context.params
 *   const { env } = getContext<MyEnv>()
 *   return json({ userId: id })
 * }
 */
export type CloudwerkHandler<TParams = Record<string, string>> = (
  request: Request,
  context: CloudwerkHandlerContext<TParams>
) => Response | Promise<Response>

/**
 * Page component signature
 */
export type PageComponent<TParams = Record<string, string>> = (
  props: PageProps<TParams>
) => unknown | Promise<unknown>

/**
 * Layout component signature
 */
export type LayoutComponent<TParams = Record<string, string>> = (
  props: LayoutProps<TParams>
) => unknown | Promise<unknown>

// ============================================================================
// Context Types
// ============================================================================

/**
 * Cloudflare Workers execution context
 */
export interface ExecutionContext {
  waitUntil(promise: Promise<unknown>): void
  passThroughOnException(): void
}

/**
 * Request-scoped context accessible via getContext()
 */
export interface CloudwerkContext<Env = Record<string, unknown>> {
  /** Original request object */
  request: Request

  /** Cloudflare bindings (D1, KV, R2, etc.) */
  env: Env

  /** Cloudflare execution context for waitUntil */
  executionCtx: ExecutionContext

  /** Route parameters from dynamic segments */
  params: Record<string, string>

  /** Auto-generated request ID for tracing */
  requestId: string

  /** Get middleware-set data */
  get<T>(key: string): T | undefined

  /** Set data for downstream code */
  set<T>(key: string, value: T): void
}

// ============================================================================
// Scanner Types
// ============================================================================

/**
 * Represents a scanned file from the filesystem
 */
export interface ScannedFile {
  /** Relative path from routes directory */
  relativePath: string

  /** Absolute path on filesystem */
  absolutePath: string

  /** File name without extension */
  name: string

  /** File extension */
  extension: SupportedExtension

  /** Detected file type */
  fileType: RouteFileType | null

  /** Whether this is inside a route group (parentheses folder) */
  isInGroup: boolean

  /** Route groups this file is nested under */
  groups: string[]
}

/**
 * Result of scanning the routes directory
 */
export interface ScanResult {
  /** All route files (page.tsx, route.ts) */
  routes: ScannedFile[]

  /** All layout files */
  layouts: ScannedFile[]

  /** All middleware files */
  middleware: ScannedFile[]

  /** All loading state files */
  loading: ScannedFile[]

  /** All error boundary files */
  errors: ScannedFile[]

  /** All not-found files */
  notFound: ScannedFile[]
}

// ============================================================================
// Middleware Types
// ============================================================================

/**
 * Cloudwerk-native middleware signature.
 *
 * Middleware receives the raw Request object and a next() function that
 * returns the downstream Response. Context data can be accessed and modified
 * via getContext().
 *
 * @example
 * ```typescript
 * import type { Middleware } from '@cloudwerk/core'
 * import { getContext, redirect } from '@cloudwerk/core'
 *
 * // Auth middleware that checks session and sets user data
 * export const middleware: Middleware = async (request, next) => {
 *   const ctx = getContext()
 *   const session = await getSession(request)
 *
 *   if (!session) {
 *     return redirect('/login')
 *   }
 *
 *   ctx.set('user', session.user)
 *   return next()
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Timing middleware that adds headers
 * export const middleware: Middleware = async (request, next) => {
 *   const start = Date.now()
 *   const response = await next()
 *
 *   // Modify response headers
 *   const duration = Date.now() - start
 *   response.headers.set('X-Response-Time', `${duration}ms`)
 *
 *   return response
 * }
 * ```
 */
export type Middleware = (
  request: Request,
  next: () => Promise<Response>
) => Response | Promise<Response>

/**
 * Module exports for middleware files.
 * Supports both default export and named 'middleware' export.
 *
 * @example
 * ```typescript
 * // Default export
 * export default async function (request, next) {
 *   return next()
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Named export
 * export const middleware = async (request, next) => {
 *   return next()
 * }
 * ```
 */
export interface LoadedMiddlewareModule {
  /** Default export middleware function */
  default?: Middleware
  /** Named 'middleware' export */
  middleware?: Middleware
}
