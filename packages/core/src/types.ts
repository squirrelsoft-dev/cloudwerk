/**
 * @cloudwerk/core - Type Definitions
 *
 * Core types for the file-based route compiler.
 */

import type { Context as HonoContext, MiddlewareHandler } from 'hono'

// Re-export Context for backward compatibility
type Context = HonoContext

// ============================================================================
// Route Segment Types
// ============================================================================

/**
 * Represents a static route segment (e.g., "about", "users")
 */
export interface StaticSegment {
  type: 'static'
  value: string
}

/**
 * Represents a dynamic route segment (e.g., "[id]" -> ":id")
 */
export interface DynamicSegment {
  type: 'dynamic'
  name: string
}

/**
 * Represents a catch-all route segment (e.g., "[...path]" -> "*path")
 */
export interface CatchAllSegment {
  type: 'catchAll'
  name: string
}

/**
 * Represents an optional catch-all route segment (e.g., "[[...cat]]" -> ":cat*")
 */
export interface OptionalCatchAllSegment {
  type: 'optionalCatchAll'
  name: string
}

/**
 * Union type for all route segment types
 */
export type RouteSegment =
  | StaticSegment
  | DynamicSegment
  | CatchAllSegment
  | OptionalCatchAllSegment

// ============================================================================
// File Type Definitions
// ============================================================================

/**
 * Supported route file types
 */
export type RouteFileType =
  | 'page'      // page.tsx, page.ts - UI routes
  | 'route'     // route.ts - API routes
  | 'layout'    // layout.tsx - Shared layouts
  | 'middleware' // middleware.ts - Route middleware
  | 'loading'   // loading.tsx - Loading states
  | 'error'     // error.tsx - Error boundaries
  | 'not-found' // not-found.tsx - 404 pages

/**
 * File extensions we support
 */
export const SUPPORTED_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx'] as const
export type SupportedExtension = typeof SUPPORTED_EXTENSIONS[number]

/**
 * Route file names we recognize
 */
export const ROUTE_FILE_NAMES = [
  'page',
  'route',
  'layout',
  'middleware',
  'loading',
  'error',
  'not-found',
] as const

// ============================================================================
// Route Entry Types
// ============================================================================

/**
 * HTTP methods supported for route handlers
 */
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'

/**
 * Represents a single route entry in the manifest
 */
export interface RouteEntry {
  /** The URL pattern for Hono (e.g., "/users/:id") */
  urlPattern: string

  /** Original file path relative to routes directory */
  filePath: string

  /** Absolute file path for importing */
  absolutePath: string

  /** Type of route file */
  fileType: RouteFileType

  /** Parsed route segments */
  segments: RouteSegment[]

  /** HTTP methods this route handles (for route.ts files) */
  methods?: HttpMethod[]

  /** Layout files that wrap this route (in order from root to closest) */
  layouts: string[]

  /** Middleware files that apply to this route (in order from root to closest) */
  middleware: string[]

  /** Priority for route sorting (lower = higher priority) */
  priority: number

  /** Route configuration (auth, rate limiting, caching, custom metadata) */
  config?: RouteConfig
}

// ============================================================================
// Route Manifest Types
// ============================================================================

/**
 * Validation error for routes
 */
export interface RouteValidationError {
  /** Type of validation error */
  type: 'conflict' | 'invalid-segment' | 'missing-file' | 'invalid-pattern'

  /** Human-readable error message */
  message: string

  /** File path(s) involved in the error */
  files: string[]
}

/**
 * Validation warning for routes (non-blocking)
 */
export interface RouteValidationWarning {
  /** Type of warning */
  type: 'unused-layout' | 'deep-nesting' | 'naming-convention'

  /** Human-readable warning message */
  message: string

  /** File path(s) involved in the warning */
  files: string[]
}

/**
 * The complete route manifest generated by the compiler
 */
export interface RouteManifest {
  /** All discovered route entries, sorted by priority */
  routes: RouteEntry[]

  /** All layout files discovered */
  layouts: Map<string, string>

  /** All middleware files discovered */
  middleware: Map<string, string>

  /** Validation errors that prevent building */
  errors: RouteValidationError[]

  /** Validation warnings (non-blocking) */
  warnings: RouteValidationWarning[]

  /** Timestamp when manifest was generated */
  generatedAt: Date

  /** Root directory that was scanned */
  rootDir: string
}

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * UI renderer configuration.
 */
export interface UIConfig {
  /**
   * Which renderer to use for JSX components.
   * @default 'hono-jsx'
   */
  renderer?: 'hono-jsx' | 'react' | 'preact'
}

/**
 * Configuration options for the route compiler
 */
export interface CloudwerkConfig {
  /** Directory containing route files (default: "app") */
  routesDir: string

  /** File extensions to scan (default: ['.ts', '.tsx']) */
  extensions: SupportedExtension[]

  /** Whether to enable strict validation (default: true) */
  strict: boolean

  /** Custom middleware to apply to all routes */
  globalMiddleware?: MiddlewareHandler[]

  /** Base path for all routes (default: "/") */
  basePath: string

  /** Whether to enable debug logging (default: false) */
  debug: boolean

  /**
   * UI renderer configuration.
   */
  ui?: UIConfig
}

/**
 * Partial config for user-provided options
 */
export type CloudwerkUserConfig = Partial<CloudwerkConfig>

// ============================================================================
// Handler Types
// ============================================================================

/**
 * Page component props
 *
 * @typeParam TParams - Route parameters type (inferred from dynamic segments)
 * @typeParam TActionData - Action data type (from action function return)
 */
export interface PageProps<
  TParams = Record<string, string>,
  TActionData = unknown
> {
  params: TParams
  searchParams: Record<string, string | string[] | undefined>
  /**
   * Data returned from the action function (present after form submission).
   * This is undefined on GET requests and only populated when an action
   * returns data (not a Response).
   */
  actionData?: TActionData
}

/**
 * Layout component props
 */
export interface LayoutProps<TParams = Record<string, string>> {
  children: unknown
  params: TParams
}

/**
 * Route handler context (extends Hono context)
 * @deprecated Use CloudwerkHandlerContext with CloudwerkHandler instead.
 * This type will be removed in a future version.
 */
export type RouteContext<TParams = Record<string, string>> = Context & {
  req: {
    param: () => TParams
  }
}

/**
 * Route handler function signature
 * @deprecated Use CloudwerkHandler instead, which provides a cleaner signature:
 * `(request: Request, context: CloudwerkHandlerContext) => Response`
 * This type will be removed in a future version.
 */
export type RouteHandler<TParams = Record<string, string>> = (
  c: RouteContext<TParams>
) => Response | Promise<Response>

// ============================================================================
// Cloudwerk Native Handler Types
// ============================================================================

/**
 * Handler context passed directly to route handlers.
 * Use getContext() for full context including env and executionCtx.
 */
export interface CloudwerkHandlerContext<TParams = Record<string, string>> {
  /** Route parameters from dynamic segments */
  params: TParams
}

/**
 * Cloudwerk-native route handler signature.
 *
 * **Important**: Both parameters must be declared for automatic detection.
 * Use `_context` if the context parameter is unused.
 *
 * @example
 * // With params
 * export function GET(request: Request, { params }: CloudwerkHandlerContext<{ id: string }>) {
 *   return json({ userId: params.id })
 * }
 *
 * @example
 * // Without params (still need second parameter for detection)
 * export function GET(request: Request, _context: CloudwerkHandlerContext) {
 *   return new Response('Hello Cloudwerk')
 * }
 *
 * @example
 * // Accessing env and request together
 * export function GET(request: Request, context: CloudwerkHandlerContext<{ id: string }>) {
 *   const { id } = context.params
 *   const { env } = getContext<MyEnv>()
 *   return json({ userId: id })
 * }
 */
export type CloudwerkHandler<TParams = Record<string, string>> = (
  request: Request,
  context: CloudwerkHandlerContext<TParams>
) => Response | Promise<Response>

/**
 * Page component signature
 */
export type PageComponent<TParams = Record<string, string>> = (
  props: PageProps<TParams>
) => unknown | Promise<unknown>

/**
 * Layout component signature
 */
export type LayoutComponent<TParams = Record<string, string>> = (
  props: LayoutProps<TParams>
) => unknown | Promise<unknown>

// ============================================================================
// Context Types
// ============================================================================

/**
 * Cloudflare Workers execution context
 */
export interface ExecutionContext {
  waitUntil(promise: Promise<unknown>): void
  passThroughOnException(): void
}

/**
 * Request-scoped context accessible via getContext()
 */
export interface CloudwerkContext<Env = Record<string, unknown>> {
  /** Original request object */
  request: Request

  /** Cloudflare bindings (D1, KV, R2, etc.) */
  env: Env

  /** Cloudflare execution context for waitUntil */
  executionCtx: ExecutionContext

  /** Route parameters from dynamic segments */
  params: Record<string, string>

  /** Auto-generated request ID for tracing */
  requestId: string

  /** Get middleware-set data */
  get<T>(key: string): T | undefined

  /** Set data for downstream code */
  set<T>(key: string, value: T): void
}

// ============================================================================
// Scanner Types
// ============================================================================

/**
 * Represents a scanned file from the filesystem
 */
export interface ScannedFile {
  /** Relative path from routes directory */
  relativePath: string

  /** Absolute path on filesystem */
  absolutePath: string

  /** File name without extension */
  name: string

  /** File extension */
  extension: SupportedExtension

  /** Detected file type */
  fileType: RouteFileType | null

  /** Whether this is inside a route group (parentheses folder) */
  isInGroup: boolean

  /** Route groups this file is nested under */
  groups: string[]
}

/**
 * Result of scanning the routes directory
 */
export interface ScanResult {
  /** All route files (page.tsx, route.ts) */
  routes: ScannedFile[]

  /** All layout files */
  layouts: ScannedFile[]

  /** All middleware files */
  middleware: ScannedFile[]

  /** All loading state files */
  loading: ScannedFile[]

  /** All error boundary files */
  errors: ScannedFile[]

  /** All not-found files */
  notFound: ScannedFile[]
}

// ============================================================================
// Middleware Types
// ============================================================================

/**
 * Cloudwerk-native middleware signature.
 *
 * Middleware receives the raw Request object and a next() function that
 * returns the downstream Response. Context data can be accessed and modified
 * via getContext().
 *
 * @example
 * ```typescript
 * import type { Middleware } from '@cloudwerk/core'
 * import { getContext, redirect } from '@cloudwerk/core'
 *
 * // Auth middleware that checks session and sets user data
 * export const middleware: Middleware = async (request, next) => {
 *   const ctx = getContext()
 *   const session = await getSession(request)
 *
 *   if (!session) {
 *     return redirect('/login')
 *   }
 *
 *   ctx.set('user', session.user)
 *   return next()
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Timing middleware that adds headers
 * export const middleware: Middleware = async (request, next) => {
 *   const start = Date.now()
 *   const response = await next()
 *
 *   // Modify response headers
 *   const duration = Date.now() - start
 *   response.headers.set('X-Response-Time', `${duration}ms`)
 *
 *   return response
 * }
 * ```
 */
export type Middleware = (
  request: Request,
  next: () => Promise<Response>
) => Response | Promise<Response>

/**
 * Module exports for middleware files.
 * Supports both default export and named 'middleware' export.
 *
 * @example
 * ```typescript
 * // Default export
 * export default async function (request, next) {
 *   return next()
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Named export
 * export const middleware = async (request, next) => {
 *   return next()
 * }
 * ```
 */
export interface LoadedMiddlewareModule {
  /** Default export middleware function */
  default?: Middleware
  /** Named 'middleware' export */
  middleware?: Middleware
}

// ============================================================================
// Route Config Types
// ============================================================================

/**
 * Authentication requirement for a route.
 *
 * - `'required'`: Request must be authenticated
 * - `'optional'`: Authentication is checked but not required
 * - `'none'`: No authentication required
 */
export type AuthRequirement = 'required' | 'optional' | 'none'

/**
 * Rate limit configuration.
 *
 * Can be a shorthand string like `'100/1m'` (100 requests per minute)
 * or an object with explicit configuration.
 *
 * @example
 * // Shorthand: "requests/window"
 * rateLimit: '100/1m'
 *
 * @example
 * // Object form
 * rateLimit: { requests: 100, window: '1m' }
 */
export type RateLimitConfig = string | {
  /** Maximum number of requests allowed */
  requests: number
  /** Time window: '1m', '1h', '1d' */
  window: string
}

/**
 * Cache configuration.
 *
 * Can be a shorthand string or an object with explicit configuration.
 *
 * @example
 * // Shorthand strings
 * cache: 'public'   // Cache-Control: public
 * cache: 'private'  // Cache-Control: private
 * cache: 'no-store' // Cache-Control: no-store
 *
 * @example
 * // Object form with max-age
 * cache: { maxAge: 3600, staleWhileRevalidate: 60 }
 */
export type CacheConfig = 'public' | 'private' | 'no-store' | {
  /** Max age in seconds */
  maxAge: number
  /** Stale-while-revalidate in seconds */
  staleWhileRevalidate?: number
}

/**
 * Route configuration object exported from route files.
 *
 * Allows declarative route-level configuration for auth, rate limiting,
 * caching, and custom metadata that middleware/plugins can access.
 *
 * @example
 * // In a route.ts file
 * import type { RouteConfig } from '@cloudwerk/core'
 *
 * export const config: RouteConfig = {
 *   auth: 'required',
 *   rateLimit: '100/1m',
 *   cache: 'private',
 * }
 *
 * export function GET(request: Request, context) {
 *   // Handler code
 * }
 */
export interface RouteConfig {
  /** Authentication requirement */
  auth?: AuthRequirement

  /** Rate limiting configuration */
  rateLimit?: RateLimitConfig

  /** Caching configuration */
  cache?: CacheConfig

  /** Custom metadata (for plugins/middleware) */
  [key: string]: unknown
}

// ============================================================================
// Loader Types
// ============================================================================

/**
 * Arguments passed to loader functions.
 *
 * Loaders receive route params, the raw request, and the Hono context
 * which provides access to cookies, headers, environment variables,
 * and middleware-set values.
 *
 * @example
 * ```typescript
 * import type { LoaderArgs } from '@cloudwerk/core'
 *
 * export async function loader({ params, request, context }: LoaderArgs<{ id: string }>) {
 *   // Access route params
 *   const userId = params.id
 *
 *   // Access cookies
 *   const session = context.req.cookie('session')
 *
 *   // Access environment variables (Cloudflare bindings)
 *   const db = context.env.DB
 *
 *   // Access middleware-set values
 *   const user = context.get('user')
 *
 *   return { userId, user }
 * }
 * ```
 */
export interface LoaderArgs<TParams = Record<string, string>> {
  /** Route parameters from dynamic segments */
  params: TParams

  /** The raw Request object */
  request: Request

  /**
   * Hono context for accessing cookies, headers, env, and middleware state.
   *
   * Common uses:
   * - `context.req.cookie('name')` - Read cookies
   * - `context.header('Cache-Control', '...')` - Set response headers
   * - `context.env.DB` - Access Cloudflare bindings
   * - `context.get('key')` - Read middleware-set values
   */
  context: HonoContext
}

/**
 * Loader function signature for server-side data loading.
 *
 * Loaders run before component rendering and provide data as props.
 * They can return data synchronously or asynchronously.
 *
 * Special behaviors:
 * - Throw `NotFoundError` to return a 404 response
 * - Throw `RedirectError` to redirect to another URL
 * - Other thrown errors will propagate and return 500
 *
 * @example
 * ```typescript
 * import type { LoaderFunction } from '@cloudwerk/core'
 * import { NotFoundError, RedirectError } from '@cloudwerk/core'
 *
 * // Async loader with typed params
 * export const loader: LoaderFunction<{ user: User }, { id: string }> = async ({
 *   params,
 *   context,
 * }) => {
 *   // Check authentication
 *   const session = context.req.cookie('session')
 *   if (!session) {
 *     throw new RedirectError('/login')
 *   }
 *
 *   // Fetch data
 *   const user = await getUser(params.id)
 *   if (!user) {
 *     throw new NotFoundError('User not found')
 *   }
 *
 *   return { user }
 * }
 * ```
 */
export type LoaderFunction<
  TData = unknown,
  TParams = Record<string, string>
> = (args: LoaderArgs<TParams>) => TData | Promise<TData>

/**
 * Helper type for inferring loader return data.
 *
 * Use this to extract the data type from a loader function for type-safe props.
 *
 * @example
 * ```typescript
 * import type { InferLoaderData, LoaderArgs, PageProps } from '@cloudwerk/core'
 *
 * export async function loader({ params }: LoaderArgs<{ id: string }>) {
 *   const user = await getUser(params.id)
 *   return { user }
 * }
 *
 * type LoaderData = InferLoaderData<typeof loader>
 * // LoaderData = { user: User }
 *
 * export default function UserPage({
 *   params,
 *   searchParams,
 *   user, // TypeScript knows this is User
 * }: PageProps<{ id: string }> & LoaderData) {
 *   return <h1>{user.name}</h1>
 * }
 * ```
 */
export type InferLoaderData<T> = T extends LoaderFunction<infer D, unknown>
  ? Awaited<D>
  : never

// ============================================================================
// Action Types
// ============================================================================

/**
 * Arguments passed to action functions.
 *
 * Actions receive route params, the raw request (for reading formData),
 * and the Hono context. This mirrors LoaderArgs for consistency.
 *
 * @example
 * ```typescript
 * import type { ActionArgs } from '@cloudwerk/core'
 *
 * export async function action({ params, request, context }: ActionArgs<{ id: string }>) {
 *   // Read form data
 *   const formData = await request.formData()
 *   const name = formData.get('name')
 *
 *   // Access cookies
 *   const session = context.req.cookie('session')
 *
 *   // Update data
 *   await updateUser(params.id, { name })
 *
 *   return { success: true }
 * }
 * ```
 */
export interface ActionArgs<TParams = Record<string, string>> {
  /** Route parameters from dynamic segments */
  params: TParams

  /** The raw Request object (use for formData(), json(), etc.) */
  request: Request

  /**
   * Hono context for accessing cookies, headers, env, and middleware state.
   *
   * Common uses:
   * - `context.req.cookie('name')` - Read cookies
   * - `context.header('Cache-Control', '...')` - Set response headers
   * - `context.env.DB` - Access Cloudflare bindings
   * - `context.get('key')` - Read middleware-set values
   */
  context: HonoContext
}

/**
 * Action function signature for handling form submissions and mutations.
 *
 * Actions run when handling POST, PUT, PATCH, or DELETE requests to a page.
 * They can return:
 * - A `Response` object (e.g., redirect, json response) - returned directly
 * - Data object - page is re-rendered with `actionData` prop
 *
 * Special behaviors:
 * - Throw `NotFoundError` to return a 404 response
 * - Throw `RedirectError` to redirect to another URL
 * - Other thrown errors will propagate and return 500
 *
 * @example
 * ```typescript
 * import type { ActionFunction } from '@cloudwerk/core'
 * import { redirect, RedirectError } from '@cloudwerk/core'
 *
 * // Return redirect Response (skips page re-render)
 * export const action: ActionFunction = async ({ request }) => {
 *   const formData = await request.formData()
 *   await saveData(formData)
 *   return redirect('/success')
 * }
 *
 * // Return data (re-renders page with actionData)
 * export const action: ActionFunction<{ errors?: Record<string, string> }> = async ({
 *   request,
 * }) => {
 *   const formData = await request.formData()
 *   const errors = validate(formData)
 *   if (errors) {
 *     return { errors }
 *   }
 *   await saveData(formData)
 *   return { success: true }
 * }
 * ```
 */
export type ActionFunction<
  TData = unknown,
  TParams = Record<string, string>
> = (args: ActionArgs<TParams>) => TData | Promise<TData>

/**
 * Helper type for inferring action return data type.
 *
 * Use this to extract the data type from an action function for type-safe props.
 *
 * @example
 * ```typescript
 * import type { InferActionData, ActionArgs, PageProps } from '@cloudwerk/core'
 *
 * export async function action({ request }: ActionArgs) {
 *   const formData = await request.formData()
 *   const errors = validate(formData)
 *   if (errors) return { errors }
 *   await save(formData)
 *   return { success: true }
 * }
 *
 * type ActionData = InferActionData<typeof action>
 * // ActionData = { errors?: Record<string, string> } | { success: boolean }
 *
 * export default function SettingsPage({
 *   actionData,
 * }: PageProps & { actionData?: ActionData }) {
 *   return (
 *     <form method="post">
 *       {actionData?.errors && <p>Error: {actionData.errors.name}</p>}
 *       {actionData?.success && <p>Saved!</p>}
 *       ...
 *     </form>
 *   )
 * }
 * ```
 */
export type InferActionData<T> = T extends ActionFunction<infer D, unknown>
  ? Awaited<D>
  : never
